{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3NA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACrBA;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://proj2try/./src/styles/style.css?ff94","webpack://proj2try/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js","webpack://proj2try/./node_modules/style-loader/dist/runtime/styleDomAPI.js","webpack://proj2try/./node_modules/style-loader/dist/runtime/insertBySelector.js","webpack://proj2try/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js","webpack://proj2try/./node_modules/style-loader/dist/runtime/insertStyleElement.js","webpack://proj2try/./node_modules/style-loader/dist/runtime/styleTagTransform.js","webpack://proj2try/./src/styles/style.css","webpack://proj2try/./node_modules/css-loader/dist/runtime/noSourceMaps.js","webpack://proj2try/./node_modules/css-loader/dist/runtime/api.js","webpack://proj2try/./node_modules/css-loader/dist/runtime/getUrl.js","webpack://proj2try/./src/styles/enter-button.css?3190","webpack://proj2try/./src/styles/enter-button.css","webpack://proj2try/./src/app.js","webpack://proj2try/./src/fleet.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/builder/transactionBuilder.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/models/collections/inputsCollection.js","webpack://proj2try/./node_modules/@fleet-sdk/common/dist/esm/utils/objectUtils.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/models/ergoUnsignedInput.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/models/ergoBox.js","webpack://proj2try/./node_modules/@noble/hashes/esm/blake2b.js","webpack://proj2try/./node_modules/@noble/hashes/esm/_blake2.js","webpack://proj2try/./node_modules/@noble/hashes/esm/_assert.js","webpack://proj2try/./node_modules/@noble/hashes/esm/utils.js","webpack://proj2try/./node_modules/@noble/hashes/esm/cryptoBrowser.js","webpack://proj2try/./node_modules/@noble/hashes/esm/_u64.js","webpack://proj2try/./node_modules/@fleet-sdk/common/dist/esm/utils/bigIntUtils.js","webpack://proj2try/./node_modules/@fleet-sdk/common/dist/esm/utils/bigIntLiterals.js","webpack://proj2try/./node_modules/@fleet-sdk/common/dist/esm/utils/arrayUtils.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/serializer/sigma/boxSerializer.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/serializer/vlq.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/duplicateInputError.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/notFoundError.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/models/collections/collection.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/models/collections/outputsCollection.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/builder/transactionBuilderSettings.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/models/collections/tokensCollection.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/maxTokensOverflow.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/insufficientTokenAmount.js","webpack://proj2try/./node_modules/@fleet-sdk/common/dist/esm/utils/stringUtils.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/models/ergoAddress.js","webpack://proj2try/./node_modules/@scure/base/lib/esm/index.js","webpack://proj2try/./node_modules/@fleet-sdk/common/dist/esm/types/common.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/invalidAddress.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/builder/pluginContext.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/notAllowedTokenBurning.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/malformedTransaction.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/nonStandardizedMinting.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/builder/outputBuilder.js","webpack://proj2try/./node_modules/@fleet-sdk/common/dist/esm/utils/boxUtils.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/invalidRegistersPacking.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/undefinedMintingContext.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/serializer/sigma/constantSerializer.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/serializer/sigma/sigmaByteWriter.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/serializer/zigZag.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/serializer/sigma/typeSerializer.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/serializer/sigma/utils.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/serializer/sigma/dataSerializer.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/serializer/sigma/sigmaTypeCode.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/serializer/sigma/sigmaByteReader.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/serializer/sigma/sigmaTypes.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/undefinedCreationHeight.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/builder/selector/boxSelector.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/builder/selector/strategies/customSelectionStrategy.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/builder/selector/strategies/accumulativeSelectionStrategy.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/duplicateInputSelectionError.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/insufficientInputs.js","webpack://proj2try/./node_modules/@fleet-sdk/core/dist/esm/errors/invalidInput.js","webpack://proj2try/webpack/bootstrap","webpack://proj2try/webpack/runtime/compat get default export","webpack://proj2try/webpack/runtime/define property getters","webpack://proj2try/webpack/runtime/global","webpack://proj2try/webpack/runtime/hasOwnProperty shorthand","webpack://proj2try/webpack/runtime/make namespace object","webpack://proj2try/webpack/runtime/publicPath","webpack://proj2try/webpack/runtime/jsonp chunk loading","webpack://proj2try/webpack/runtime/nonce","webpack://proj2try/./src/index.js"],"sourcesContent":["\n      import API from \"!../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../../node_modules/css-loader/dist/cjs.js!./style.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\n\n      options.insert = insertFn.bind(null, \"head\");\n    \noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../../node_modules/css-loader/dist/cjs.js!./style.css\";\n       export default content && content.locals ? content.locals : undefined;\n","\"use strict\";\n\nvar stylesInDOM = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n\n  return updater;\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};","\"use strict\";\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n\n  var needLayer = typeof obj.layer !== \"undefined\";\n\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n\n  css += obj.css;\n\n  if (needLayer) {\n    css += \"}\";\n  }\n\n  if (obj.media) {\n    css += \"}\";\n  }\n\n  if (obj.supports) {\n    css += \"}\";\n  }\n\n  var sourceMap = obj.sourceMap;\n\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  options.styleTagTransform(css, styleElement, options.options);\n}\n\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n\n  styleElement.parentNode.removeChild(styleElement);\n}\n/* istanbul ignore next  */\n\n\nfunction domAPI(options) {\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\n\nmodule.exports = domAPI;","\"use strict\";\n\nvar memo = {};\n/* istanbul ignore next  */\n\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n\n    memo[target] = styleTarget;\n  }\n\n  return memo[target];\n}\n/* istanbul ignore next  */\n\n\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n\n  target.appendChild(style);\n}\n\nmodule.exports = insertBySelector;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce = typeof __webpack_nonce__ !== \"undefined\" ? __webpack_nonce__ : null;\n\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\n\nmodule.exports = setAttributesWithoutAttributes;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\n\nmodule.exports = insertStyleElement;","\"use strict\";\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\n\nmodule.exports = styleTagTransform;","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nimport ___CSS_LOADER_GET_URL_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/getUrl.js\";\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(\"../assets/fonts/Mechfire_Bold.otf\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_1___ = new URL(\"../assets/fullbar.webp\", import.meta.url);\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n___CSS_LOADER_EXPORT___.push([module.id, \"@import url(https://fonts.googleapis.com/css2?family=Montserrat&display=swap);\"]);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* Main Styling */\\n\\n@font-face {\\n    font-family: pixelFont;\\n    src: url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \") format(\\\"opentype\\\");\\n    font-display:swap;\\n}\\n\\n:root {\\n    --yellow: #F7FC19;\\n    --pink: #EE2DFF;\\n    --blue: #0B0029;\\n    --bg: var(--blue);\\n\\n    --red: #FF0000;\\n    --purple: #811CB0;\\n    --teal: #2fa388;\\n    --blue-purple: #2f4aa3;\\n    --light-red: #a32f4a;\\n    --dark-yellow: #a3882f;\\n    --black: #000000;\\n    --white: #FFFFFF;\\n    --grey: #92a5ce;\\n    --bg-header: rgba(0, 0, 0, 0.9);\\n    --nav-hover: var(--pink);\\n\\n    --step-0: clamp(1.31rem, 1.24rem + 0.37vw, 1.50rem);\\n    --step-1: clamp(1.58rem, 1.02rem + 2.78vw, 3.00rem);\\n    --step-2: clamp(1.89rem, 0.29rem + 8.02vw, 6.00rem);\\n    --step-3: clamp(2.27rem, -1.53rem + 18.99vw, 12.00rem);\\n    --step-4: clamp(2.72rem, -5.58rem + 41.52vw, 24.00rem);\\n    --step-5: clamp(3.27rem, -14.19rem + 87.29vw, 48.00rem);\\n}\\n\\n*,\\n*:before,\\n*:after {\\n    box-sizing: border-box;\\n}\\niframe#iframetrailer {\\n    display:flex;\\nmargin-bottom:2.5rem;\\nmargin-top:-2rem;\\n\\n\\n}\\n#faqcont {\\n    text-align:center;\\n}\\n#mintbtn {\\n    display:block;\\n    background-color:black;\\n    color:yellow;\\n }\\n #mintbtn:hover {\\n    color:var(--pink)\\n }\\n.modal {\\n    display: none; /* Hidden by default */\\n    position: fixed; /* Stay in place */\\n    z-index: 1; /* Sit on top */\\n    padding-top: 100px; /* Location of the box */\\n   \\n    width: 100%; /* Full width */\\n    height: 100%; /* Full height */\\n    overflow: auto; /* Enable scroll if needed */\\n    background-color: rgb(0,0,0); /* Fallback color */\\n    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */\\n  }\\n  \\n\\n  .close:hover,\\n  .close:focus {\\n    color: yellow;\\n    text-decoration: none;\\n    cursor: pointer;\\n  }\\n#yellow {\\n    color:yellow;\\n}\\n  .modal-content {\\n      background-color:black;\\n      margin: auto;\\n      padding: 20px;\\n      border: 1px solid #888;\\n      width: 50%;\\n      margin-top:7%;\\n      font-family:Arial, Helvetica, sans-serif;\\n      height:auto;\\n      animation-name: animatetop;\\n      animation-duration: 0.4s\\n    }\\n\\n    @keyframes animatetop {\\n        from {top: -300px; opacity: 0}\\n        to {top: 0; opacity: 1}\\n      }\\n\\n\\ninput:focus,\\nselect:focus,\\ntextarea:focus,\\nbutton:focus {\\n    outline: none;\\n}\\n\\na {\\n    text-decoration: none;\\n    color: var(--yellow);\\n    text-transform: uppercase;\\n    border: 2px solid var(--pink);\\n    border-radius: 12px;\\n    padding: 6px;\\n    max-width: 10rem;\\n    margin: 0 auto;\\n}\\n\\na:hover {\\n    color: var(--pink);\\n}\\n\\nhtml {\\n    margin: 0;\\n    padding: 0;\\n    color: var(--white);\\n    font-family: pixelFont;\\n    scroll-behavior: smooth;\\n}\\n#monthdisplay {\\nfont-size:larger;\\n    color: black;\\n    text-shadow: -0.05px -0.25px 0 yellow, 0.25px -0.25px 0 yellow, -0.25px 0.25px 0 yellow, 0.25px 0.25px 0 yellow;\\n  }\\nbody {\\n    margin: 0;\\n    padding: 0;\\n\\n    border: 0;\\n\\n    overflow-x:hidden;\\n    \\n\\n    background-color: var(--bg);\\n}\\n#statsdisplay {\\n   color:var(--pink);\\n\\n}\\nimg#balanceicon, #cypxicon {\\n    width:2.5rem;\\n    height:2.5rem;\\n    display:flex;\\n  \\n\\n\\n}\\n#usertokens {\\n    font-family:Arial, Helvetica, sans-serif;\\n}\\nspan#userbalance{\\nvertical-align:center;\\ndisplay:flex;\\nfont-size:75%;\\n\\n}\\nspan#cypxbalance{\\n\\n    display:flex;\\n    font-size:75%;\\n    \\n    }\\n    \\nheader {\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    background-color: var(--bg-header);\\n    width: 100vw;\\nz-index:999;\\n    display: grid;\\n    grid-template-columns: 1fr auto minmax(600px, 3fr) 1fr;\\n}\\n\\nspan {\\n    color: var(--pink);\\n}\\na#dashboardbtn {\\n    font-size:smaller;\\n}\\n.nav-links {\\n    text-transform: uppercase;\\n    margin: 0;\\n    padding: 0;\\n    list-style: none;\\n    font-size: 1.25rem;\\n\\n    display: flex;\\n    align-items: center;\\n}\\n\\n.nav-toggle {\\n    display: none;\\n}\\nimg#ScrollTop {\\nwidth:120%;\\nheight:auto;\\n}\\n\\n.nav-toggle-label {\\n    display: none;\\n    cursor: pointer;\\n}\\n\\n.logo {\\n  \\n    cursor: initial;\\n    padding: 1em;\\n}\\n\\n.logo img {\\n  width:120%;\\n    cursor: pointer;\\n}\\n\\nnav {\\n    grid-column: 2 / 5;\\n    display: flex;\\n    justify-content: flex-end;\\n    align-items: center;\\n    padding-right: 2em;\\n    gap: 2em;\\n    z-index:99;\\n}\\n\\nnav ul {\\n    display: flex;\\n    justify-content: flex-end;\\n    min-width: 100%;\\n}\\n\\nnav a {\\n    margin-left: 1em;\\n    margin-bottom: 0;\\n    position: relative;\\n}\\n\\nnav a:hover {\\n    color: var(--nav-hover);\\n}\\n\\nnav a::before {\\n    content: '';\\n    display: block;\\n    height: 5px;\\n    background: var(--nav-hover);\\n    position: absolute;\\n    top: -1em;\\n    left: 0;\\n    right: 0;\\n\\n    transform: scale(0, 1);\\n    transition: transform ease-in-out 250ms;\\n}\\n\\nnav a:hover::before {\\n    transform: scale(1, 1);\\n}\\n\\n#discord-desktop,\\n#twitter-desktop {\\n    margin-right: 10px;\\n    border: none;\\n}\\n\\n#discord-desktop {\\n    filter: invert(65%) sepia(79%) saturate(2780%) hue-rotate(199deg) brightness(90%) contrast(88%);\\n}\\n\\n#twitter-desktop {\\n    filter: invert(68%) sepia(75%) saturate(2575%) hue-rotate(179deg) brightness(99%) contrast(88%);\\n}\\n\\n#discord-desktop::before,\\n#twitter-desktop::before {\\n    display: none;\\n}\\n\\n.fade-in {\\n    opacity: 0;\\n    transition: 250ms ease-in;\\n}\\n\\n.fade-in.appear {\\n    opacity: 1;\\n}\\n\\nh1 {\\n    line-height: 1;\\n    font-size: 2rem;\\n    padding: 2rem;\\n    color: var(--yellow);\\n}\\n\\n.mint-title {\\n    font-size: 1.5rem;\\n}\\n#mint-button {\\n    background-color:transparent;\\n    border:1px solid var(--pink);\\n    color:yellow;\\nfont-family:pixelFont;\\ndisplay:flex;\\nmargin-inline:auto;\\nfont-size:2rem;\\n}\\n#mint-button:hover {\\n    background-color:transparent;\\n    border:1px solid var(--purple);\\n    color:yellow;\\nfont-family:pixelFont;\\ndisplay:flex;\\nmargin-inline:auto;\\nfont-size:2rem;\\ncursor:pointer;\\n}\\n.address-title {\\n    font-size: 1.5rem;\\n}\\n\\n.address-p2k {\\n    font-size: 1rem;\\n    max-width: 90%;\\n    word-wrap: break-word;\\n    cursor: pointer;\\n    color:yellow;\\n}\\n\\n.address-p2k:hover {\\n    color: var(--purple);\\n}\\n\\n.auctions-text {\\n    font-size: 1rem;\\n    max-width: 90%;\\n    word-wrap: break-word;\\n}\\n\\nh2 {\\n    text-align: center;\\n    text-transform: uppercase;\\n    color: var(--pink);\\n    font-size: 3rem;\\n}\\n.spinner {\\n background-color:transparent;\\n    background-repeat: no-repeat;\\n    background-size: 40px 40px; /* adjust as necessary */\\n    width: 40px; /* adjust as necessary */\\n    height: 40px; /* adjust as necessary */\\n    margin: 0 auto; /* centers the spinner horizontally */\\n  }\\nh3 {\\n    font-size: 2rem;\\n}\\n\\nh4 {\\n    font-size: 1.5rem;\\n}\\n#modaltitle {\\n    color:var(--yellow);\\n    text-align:center;\\n}\\n#modaladdy {\\n    display:block;\\n text-align:center;\\n    width:100%;\\n  \\n}\\n.image-modal {\\n    text-align:center;\\n    display:flex;\\n    margin-inline:auto;\\n    width:25%;\\n    height:auto;\\n}\\n#modal-text{\\n    display:block;\\n text-align:center;\\n    width:100%;\\n  \\n}\\n#copyremind {\\n    font-size:0.6rem;\\n    text-align:center;\\n   margin-top:-20px;\\n}\\np {}\\n\\n#mint,\\n#explore,\\n.unsold {\\n    font-size: 1.5rem;\\n}\\n\\nsection {\\n    min-height: 50vh;\\n    display: flex;\\n    flex-direction: column;\\n    gap: 3rem;\\n    align-items: center;\\n\\n    /* border-glow-here */\\n    background: hsla(295, 100%, 59%, 1);\\n\\n    background: linear-gradient(90deg, hsla(295, 100%, 59%, 1) 0%, hsla(256, 100%, 8%, 1) 1%, hsla(256, 100%, 8%, 1) 99%, hsla(295, 100%, 59%, 1) 100%);\\n\\n    background: -moz-linear-gradient(90deg, hsla(295, 100%, 59%, 1) 0%, hsla(256, 100%, 8%, 1) 1%, hsla(256, 100%, 8%, 1) 99%, hsla(295, 100%, 59%, 1) 100%);\\n\\n    background: -webkit-linear-gradient(90deg, hsla(295, 100%, 59%, 1) 0%, hsla(256, 100%, 8%, 1) 1%, hsla(256, 100%, 8%, 1) 99%, hsla(295, 100%, 59%, 1) 100%);\\n\\n    filter: progid: DXImageTransform.Microsoft.gradient(startColorstr=\\\"#EE2DFF\\\", endColorstr=\\\"#0B0029\\\", GradientType=1);\\n}\\n\\nsection h2 {\\n    padding-top: 3rem;\\n}\\n\\n.flex-container,\\n.flex-container-faq,\\n.flex-container-mint,\\n.flex-container-roadmap,\\n.flex-container-team {\\n    padding-bottom: 3rem;\\n}\\n\\n.s1 {\\n    min-height: 100vh;\\n    flex-direction: column;\\n    justify-content: center;\\n    background-color: var(--black);\\n\\n    background-image: url(\" + ___CSS_LOADER_URL_REPLACEMENT_1___ + \");\\n    background-position: center;\\n    background-size: cover;\\n    background-repeat: no-repeat;\\n}\\n\\n.logo {\\n    height:auto;\\n    width:35%;\\n}\\n.flex-container {\\n    display: flex;\\n    flex-direction: column;\\n    text-align: center;\\n    text-transform: capitalize;\\n    padding-bottom: 4em;\\n}\\n\\n.flex-container-mint {\\n    display: flex;\\n    max-width: 90%;\\n    margin: 6em auto;\\n}\\n\\n.container-mint {\\n    display: flex;\\n    flex-direction: column;\\n    max-width: 40%;\\n    margin: 0 auto;\\n}\\n.close {\\n    color: #aaaaaa;\\n    float: right;\\n    font-size: 28px;\\n    font-weight: bold;\\n\\n  }\\n  .maintext {\\n    color:var(--yellow)\\n    \\n  }\\n  \\n  #calendar {\\n    display:flex;\\n    position:relative;\\n    color:yellow;\\n    background-color:transparent;\\n\\n   bottom:-10.25rem;\\n    left: 42.9%; /* adjust as needed */\\n\\n    z-index: 50;\\n    width: 12.5%;\\n    height: 5rem;\\n  }\\n\\n  #calendar button {\\n    background-color:black;\\n    color:var(--pink);\\n    cursor:pointer;\\nwidth:auto;\\nheight:auto;\\n  }\\n  #calendar button:hover {\\n    background-color:black;\\n    color:var(--yellow);\\n\\n  }\\n#closedashboard {\\n    position:absolute;\\n    margin-left:72%;\\n    margin-top:8%;\\n}\\n#dashboardbtn:hover {\\ncursor:pointer;\\n}\\n#datemodal {\\n    text-align:center;\\n    background-color:black;\\n    z-index:51;\\n\\n}\\n#closedatepoints {\\n    margin-right:85%;\\n    margin-bottom:2rem;\\n}\\n.container-mint h3 {\\n    color: var(--yellow);\\n    margin-bottom: 0;\\n}\\n\\n.container-mint p {\\n    margin-top: 0.5em;\\n}\\n\\n.container-mint h2 {\\n    text-align: left;\\n}\\n\\n.container-mint-img {\\n    gap: 1em;\\n    justify-content: center;\\n}\\n\\n.container-mint-img a {\\n    text-align: center;\\n}\\n\\n.container-mint img {\\n    width: auto;\\n    height: auto;\\n    max-width: 50%;\\n    margin: 0 auto;\\n    border-radius: 12px;\\n}\\n\\n.unsold {\\n    text-align: center;\\n    color: var(--yellow);\\n}\\n\\n.flex-container-roadmap {\\n    max-width: 90%;\\n    margin: 0 auto;\\n    display: flex;\\n    gap: 3em;\\n}\\n\\n.container-r1,\\n.container-r2 {\\n    flex-basis: 50%;\\n}\\n\\n.container-r1 h3,\\n.container-r2 h3 {}\\n\\n.roadmap-title {\\n    color: var(--pink);\\n    font-size: 3rem;\\n}\\n\\nul {\\n    padding: 0;\\n}\\n\\n.container-r1 li,\\n.container-r2 li {\\n    list-style-type: none;\\n}\\n\\nli h4 {\\n    text-transform: uppercase;\\n    color: var(--yellow);\\n    font-size: 1.5rem;\\n}\\n\\nli p {\\n    font-size: 1.25rem;\\n    font-family: 'Montserrat', sans-serif;\\n}\\n\\n#cybercity-map {\\n    max-width: 80vw;\\n    margin: 0 auto;\\n    border: 2px solid var(--pink);\\n    border-radius: 12px;\\n}\\n\\n.flex-container-team>* {\\n    flex-basis: 20%;\\n}\\n\\n.flex-container-team {\\n    display: flex;\\n    max-width: 90%;\\n    margin: 0 auto;\\n    flex-direction: row;\\n    /* flex-wrap: nowrap; */\\n}\\n\\n.team-column {\\n    max-width: 20%;\\n    text-align: center;\\n}\\n\\n.team-member-name {\\n    text-transform: uppercase;\\n    color: var(--yellow);\\n    margin-bottom: 2%;\\n}\\n\\n.team-member-description {\\n    text-transform: uppercase;\\n    font-size: 1.5rem;\\n    word-wrap: break-word;\\n\\n}\\n\\n.team-member-image {\\n    max-width: 60%;\\n    border-radius: 12px;\\n}\\n\\n.flex-container-faq {\\n    display: flex;\\n    flex-direction: column;\\n    max-width: 90%;\\n    gap: 0;\\n}\\n\\n.faq-header,\\n.faq-answer {\\n    text-align: center;\\n    margin: 0 auto;\\n    max-width: 60%;\\n}\\n\\n.faq-header {\\n    text-transform: uppercase;\\n    color: var(--yellow);\\n    margin-bottom: 0.25rem;\\n    font-size: 1.5rem;\\n}\\n\\n.faq-answer {\\n    margin-bottom: 1em;\\n    font-size: 1.25rem;\\n    font-family: 'Montserrat', sans-serif;\\n}\\n\\n.faq-links {\\n    border: none;\\n}\\n\\n#ergopixel-img {\\n    border: 3px solid var(--pink);\\n}\\n\\n.footer-container {\\n    display: flex;\\n    flex-direction: column;\\n}\\n\\n.footer-container a {\\n    border: none;\\n}\\n\\n.footer-logo {\\n    width: 10%;\\n    margin-top: 1em;\\n    padding-bottom: 1em;\\n}\\n.ccimage {\\n    width:100px;\\n    height:100px;\\n}\\n.assetdescription {\\n    font-size:larger;\\n    color:var(--pink)\\n}\\n.assetcont {\\n    border:1px solid var(--purple)\\n}\\n.dashboardcont {\\n    display:block;\\n    position:absolute;\\n    background-color:black;\\n    border:1px solid pink;\\nmargin-left:25%;\\nmargin-top:10%;\\n}\\n.play-button {\\n    background-color:Yellow;\\n}\\n#dashboard, #audio-nfts {\\n    display:block;\\n    justify-content:center;\\n    align-items:center;\\n    text-align:Center;\\n}\\n.assettitle {\\n    font-size:larger;\\n    color:yellow;\\n}\\n.footer-logo-container {\\n    display: flex;\\n    justify-content: center;\\n    border-bottom: 2px solid var(--pink);\\n    max-width: 90%;\\n    margin: 0 auto;\\n}\\nbutton.disabled {\\n    background-color: red;\\n    cursor: not-allowed;\\n  }\\n  #mintbtn[disabled] {\\n    background-color: red;\\n  }\\n.svg-container {\\n    display: flex;\\n    justify-content: space-around;\\n}\\n\\n.svg-container a {\\n    width: 50%;\\n    text-align: center;\\n}\\n\\n.discord,\\n.twitter {\\n    max-width: 50%;\\n}\\n\\n.footer-text {\\n    margin-bottom: 1em;\\n    text-align: center;\\n}\\n\\n.svg-container {\\n    justify-content: center;\\n    margin: auto auto;\\n    min-width: 50%;\\n}\\n\\n.svg-container a {\\n    margin: 0;\\n    gap: 0;\\n}\\n\\n.svg-container a img {\\n    padding-top: 1em;\\n    width: 40%;\\n}\\n\\n.footer-logo {\\n    width: 10%;\\n}\\n\\n.footer-text {\\n    padding: 1em;\\n}\\n\\n.twitter,\\n.discord {\\n    filter: invert(98%) sepia(95%) saturate(6%) hue-rotate(306deg) brightness(103%) contrast(100%);\\n}\\n\\n#wallet {\\n    cursor: pointer;\\n}\\n\\n#wallet-connector {\\n    position: fixed;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    min-width: 50%;\\n    min-height: 30%;\\n    padding: 1em;\\n    background-color: black;\\n    border-radius: 20px;\\n    color: var(--yellow);\\n    text-shadow: 1px 1px #258ae8;\\n    display: none;\\n    z-index: 200;\\n}\\n\\n#wallet-connector p {\\n    padding-bottom: 2%;\\n    font-size: 1.5rem;\\n}\\n\\n#wallet-connector input {\\n    width: 100%;\\n    margin: 0 auto;\\n    font-size: 1.25rem;\\n}\\n\\n#wallet-connector.open {\\n    z-index: 100;\\n    background-color: var(--blue);\\n    border: 2px var(--pink) solid;\\n    display: block;\\n}\\n\\n#wallet-address-text {\\n    font-weight: 100;\\n}\\n\\n#wallet-output {\\n    padding-top: 2%;\\n    color: red;\\n}\\n\\n#wallet-buttons {\\n    display: flex;\\n    justify-content: end;\\n    gap: 1em;\\n    width: 100%;\\n    margin: 0 auto;\\n}\\n\\n.wallet-button {\\n    all: unset;\\n    min-width: 10%;\\n    background-color: var(--pink);\\n    border: 1px var(--pink) solid;\\n    text-align: center;\\n    font-size: 1.5rem;\\n    border-radius: 10px;\\n    cursor: pointer;\\n    transition: ease-in 0.2s;\\n    padding: 1%;\\n    color: var(--yellow);\\n    text-shadow: 1px 1px #258ae8;\\n}\\n\\n.wallet-button:hover {\\n    border: 2px #258ae8 solid;\\n}\\n#connectbtn {\\n    background-color:transparent;\\n    color:yellow;\\n}\\n#finish {\\n    background-color: #258ae8;\\n    border: 2px #258ae8 solid;\\n}\\n\\n#finish:hover {\\n    border: 2px var(--pink) solid;\\n}\\n\\ninput[type=text],\\ntextarea {\\n    border: 2px #f711f7 solid;\\n    background-color: var(--bblue);\\n    border-radius: 20px;\\n    color: var(--yellow);\\n    font-family: pixelFont;\\n}\\n\\ninput[type=text]:focus,\\ntextarea:focus,\\ninput[type=text]:hover,\\ntextarea:hover {\\n    border: 2px var(--pink) solid;\\n}\\n\\n#dino-mobile,\\n#twitter-mobile,\\n#discord-mobile {\\n    display: none;\\n}\\n\\nli #dino-image {\\n    flex-grow: 0;\\n    flex-basis: 10%;\\n}\\n\\n#dino-image {\\n    width: auto;\\n    height: auto;\\n    max-width: 25px;\\n    max-height: 20px;\\n}\\n\\nli #header-image {\\n    flex-grow: 1;\\n    flex-basis: 10%;\\n}\\n\\n#header-image {\\n    width: auto;\\n    height: auto;\\n    max-width: 30px;\\n    max-height: 25px;\\n    border-color: red;;\\n}\\n\\n.benefits-list {\\n    padding-left: 4%;\\n}\\n\\n.benefit-title {\\n    font-size: 1.9rem;\\n    color: var(--pink);\\n}\\n\\n.benefit {\\n    font-size: 1.25rem;\\n    color:var(--yellow)\\n}\\n\\n.container-r1,\\n.container-r2 {\\n    margin: 0 auto;\\n}\\n\\n#roadmap-switch {\\n    margin-bottom: 4em;\\n    cursor: pointer;\\n    font-size: 1.5rem;\\n    max-width: none;\\n}\\n\\n@media all and (max-width : 60em) {\\n    header {\\n        display: block;\\n        text-align: center;\\n        z-index: 999;\\n        min-width: 10vh;\\n    }\\n    body{\\n        width:100%;\\n        overflow-x:hidden;\\n        \\n    }\\n    #wallet-btn {\\n        display:none;\\n    }\\niframe#iframetrailer {\\n    width:75%;\\n    height:auto;\\n}\\n    .logo {\\n        padding-top: 0.5em;\\n        padding-bottom: 0.5em;\\n        font-size: 2rem;\\n       margin-inline:auto;\\n    }\\n\\n    #cybercity-map {\\n        max-width: 90%;\\n        margin: 0 auto;\\n    }\\n\\n    /* Look for any nav as a preceding sibling */\\n    .nav-toggle:checked~nav {\\n        transform: scale(1, 1);\\n    }\\n\\n    .nav-toggle:checked~nav .nav-links li a {\\n        opacity: 1;\\n        transition: opacity 250ms ease-in-out 350ms;\\n    }\\n\\n    .nav-toggle-label {\\n        position: absolute;\\n        top: 0;\\n        left: 0;\\n        height: 100%;\\n        display: flex;\\n        align-items: center;\\n        margin-left: 1em;\\n    }\\n\\n    /* Create hamburger */\\n    .nav-toggle-label>span,\\n    .nav-toggle-label>span::before,\\n    .nav-toggle-label>span::after {\\n        display: block;\\n        background: var(--pink);\\n        height: 2px;\\n        width: 2em;\\n        border-radius: 2px;\\n        position: relative;\\n    }\\n\\n    /* Make sure the pseudo-elements have content so they display */\\n    .nav-toggle-label>span::before,\\n    .nav-toggle-label>span::after {\\n        content: '';\\n        position: absolute;\\n    }\\n\\n    /* Move the before pseudo-element down */\\n    .nav-toggle-label>span::before {\\n        bottom: 7px;\\n    }\\n\\n    /* Move the after pseudo-element up */\\n    .nav-toggle-label>span::after {\\n        top: 7px;\\n    }\\n\\n    nav {\\n        position: absolute;\\n        text-align: left;\\n        top: 100%;\\n        left: 0;\\n        background-color: var(--bg-header);\\n\\n        transform: scale(1, 0);\\n        transform-origin: top;\\n        transition: transform 400ms ease-in-out;\\n    }\\n\\n    nav ul {\\n        display: block;\\n    }\\n\\n    nav a {\\n        margin-left: 0;\\n        border: none;\\n    }\\n\\n    nav a::before {\\n        display: none;\\n    }\\n\\n    .nav-links {\\n        padding-top: 1em;\\n        width: 100vw;\\n        border-bottom: 2px solid var(--pink);\\n        flex-direction: column;\\n        align-items: flex-start;\\n    }\\n\\n    .nav-links>li {\\n        margin-bottom: 1em;\\n        margin-left: 1em;\\n    }\\n\\n    .nav-links>li>a {\\n        opacity: 0;\\n        transition: opacity 100ms ease-in-out;\\n    }\\n\\n    .nav-links>li>a:hover {\\n        color: var(--nav-hover);\\n    }\\n\\n\\n    .flex-container,\\n    .flex-container-faq,\\n    .flex-container-mint,\\n    .flex-container-roadmap,\\n    .flex-container-team {\\n        flex-direction: column;\\n    }\\n\\n    .flex-container-mint>* {\\n        margin: 0 auto;\\n        min-width: 90%;\\n    }\\n\\n    .container-mint h2 {\\n        text-align: center;\\n    }\\n\\n    .flex-container-mint {\\n        margin: 3rem 0;\\n        padding: 0;\\n        width: 90%;\\n    }\\n\\n    .flex-container-mint h2 {\\n        min-width: 90%;\\n    }\\n\\n    .container-mint img {\\n        max-width: 75%;\\n    }\\n\\n\\n    .container-mint img {\\n        width: auto;\\n        height: auto;\\n        max-width: 80%;\\n        margin: 0 auto;\\n    }\\n\\n    .faq-header,\\n    .faq-answer {\\n        text-align: center;\\n        margin: 1em auto;\\n        max-width: 90%;\\n    }\\n\\n    .flex-container-team {\\n        flex-direction: column;\\n    }\\n\\n    .flex-container-team>* {\\n        flex-basis: 100%;\\n    }\\n\\n    .flex-container-team {\\n        justify-content: center;\\n        align-items: center;\\n    }\\n\\n    .team-member-image {\\n        margin-top: 3rem;\\n        max-width: 60%;\\n    }\\n\\n    .team-column {\\n        min-width: 90%;\\n    }\\n\\n    .footer-logo {\\n        width: 40%;\\n    }\\n\\n    #wallet-connector {\\n        width: 90% !important;\\n    }\\n\\n    #wallet-connector p {\\n        padding-bottom: 2%;\\n        font-size: 1.25rem;\\n    }\\n\\n    #wallet-connector input {\\n        width: 100%;\\n        margin: 0 auto;\\n        font-size: 1.125rem;\\n    }\\n\\n    .wallet-button {\\n        font-size: 1.125rem;\\n    }\\n\\n    #dino-desktop,\\n    #discord-desktop,\\n    #twitter-desktop {\\n        display: none;\\n    }\\n\\n    #dino-mobile,\\n    #twitter-mobile,\\n    #discord-mobile {\\n        display: inline-block;\\n        padding-bottom: 0;\\n        padding-top: 0;\\n    }\\n\\n    .desktop-li {\\n        display: none;\\n    }\\n}\\n\\n@media all and (max-width : 40em) {\\n    #nft-container {\\n        flex-direction: column;\\n    }\\n\\n    .auction-card-modal h2 {\\n        font-size: 1rem;\\n    }\\n\\n    .nav-links {\\n        font-size: 1rem;\\n    }\\n\\n    .roadmap-title {\\n        font-size: 2rem;\\n    }\\n\\n    h1 {\\n        font-size: 1rem;\\n    }\\n\\n    h2 {\\n        font-size: 1.5rem;\\n    }\\n\\n    h3 {\\n        font-size: 1rem;\\n    }\\n\\n    .flex-container-faq {\\n        max-width: 90%;\\n    }\\n\\n    li h4 {\\n        font-size: 1.5rem;\\n    }\\n\\n    .benefits-list {\\n        padding-left: 4%;\\n    }\\n\\n    .benefit-title {\\n        font-size: 1.3rem;\\n    }\\n\\n    .benefit {\\n        font-size: 1.125rem;\\n    }\\n\\n    li p {\\n        font-size: 1.25rem;\\n    }\\n\\n    .team-member-name {\\n        font-size: 1.5rem;\\n    }\\n\\n    .team-member-description {\\n        font-size: 1.25rem;\\n    }\\n\\n    .faq-header {\\n        font-size: 1.5rem;\\n    }\\n\\n    .faq-answer {\\n        word-wrap: break-word;\\n        font-size: 1.25rem;\\n    }\\n\\n    .footer-logo {\\n        width: 40%;\\n    }\\n\\n    .footer-text {\\n        font-size: 1rem;\\n    }\\n\\n    #wallet-connector {\\n        width: 90% !important;\\n        top: 60%;\\n    }\\n\\n    #wallet-connector p {\\n        padding-bottom: 2%;\\n        font-size: 1rem;\\n    }\\n\\n    #wallet-connector input {\\n        width: 100%;\\n        margin: 0 auto;\\n        font-size: 1rem;\\n    }\\n\\n    .wallet-button {\\n        font-size: 1rem;\\n    }\\n}\", \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","\"use strict\";\n\nmodule.exports = function (i) {\n  return i[1];\n};","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};","\"use strict\";\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url[\"default\"] : url);\n\n  // If url is already wrapped in quotes, remove them\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  }\n\n  // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n  return url;\n};","\n      import API from \"!../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n      import domAPI from \"!../../node_modules/style-loader/dist/runtime/styleDomAPI.js\";\n      import insertFn from \"!../../node_modules/style-loader/dist/runtime/insertBySelector.js\";\n      import setAttributes from \"!../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\";\n      import insertStyleElement from \"!../../node_modules/style-loader/dist/runtime/insertStyleElement.js\";\n      import styleTagTransformFn from \"!../../node_modules/style-loader/dist/runtime/styleTagTransform.js\";\n      import content, * as namedExport from \"!!../../node_modules/css-loader/dist/cjs.js!./enter-button.css\";\n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = styleTagTransformFn;\noptions.setAttributes = setAttributes;\n\n      options.insert = insertFn.bind(null, \"head\");\n    \noptions.domAPI = domAPI;\noptions.insertStyleElement = insertStyleElement;\n\nvar update = API(content, options);\n\n\n\nexport * from \"!!../../node_modules/css-loader/dist/cjs.js!./enter-button.css\";\n       export default content && content.locals ? content.locals : undefined;\n","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/api.js\";\nimport ___CSS_LOADER_GET_URL_IMPORT___ from \"../../node_modules/css-loader/dist/runtime/getUrl.js\";\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(\"../assets/newMap.png\", import.meta.url);\nvar ___CSS_LOADER_URL_IMPORT_1___ = new URL(\"../assets/enter-estate-background.png\", import.meta.url);\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = ___CSS_LOADER_GET_URL_IMPORT___(___CSS_LOADER_URL_IMPORT_1___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n\\ndiv.enter-estate-container { \\nmargin-top:22%;\\n  display:flex;\\n margin-left:65%;\\n position:absolute;\\nwidth:12.5rem;\\nheight:10rem;\\n\\n }\\n \\n/* animations for background image */\\n@-webkit-keyframes pulseBox {\\n  0% {\\n    -webkit-box-shadow: 0px 0px 10px 0px rgba(225, 0, 255, 0.3);\\n  }\\n  100% {\\n    -webkit-box-shadow: 0px 0px 18px 0px rgba(225, 0, 255, 1);\\n  }\\n}\\n@-moz-keyframes pulseBox {\\n  0% {\\n    -moz-box-shadow: 0px 0px 10px 0px rgba(225, 0, 255, 0.3);\\n  }\\n  100% {\\n    -moz-box-shadow: 0px 0px 18px 0px rgba(225, 0, 255, 1);\\n  }\\n}\\n@-o-keyframes pulseBox {\\n  0% {\\n    -o-box-shadow: 0px 0px 10px 0px rgba(225, 0, 255, 0.3);\\n  }\\n  100% {\\n    -o-box-shadow: 0px 0px 18px 0px rgba(225, 0, 255, 1);\\n  }\\n}\\n@keyframes pulseBox {\\n  0% {\\n    box-shadow: 0px 0px 10px 0px rgba(225, 0, 255, 0.3);\\n  }\\n  100% {\\n    box-shadow: 0px 0px 18px 0px rgba(225, 0, 255, 1);\\n  }\\n}\\n/* class pulsebox for glowing border */\\n.pulseBox {\\n  -webkit-animation-name: pulseBox;\\n  -moz-animation-name: pulseBox;\\n  -o-animation-name: pulseBox;\\n  animation-name: pulseBox;\\n  -webkit-animation-duration: 1s;\\n  -moz-animation-duration: 1s;\\n  -o-animation-duration: 1s;\\n  animation-duration: 1s;\\n  -webkit-animation-iteration-count: infinite;\\n  -moz-animation-iteration-count: infinite;\\n  -o-animation-iteration-count: infinite;\\n  animation-iteration-count: infinite;\\n  -webkit-animation-direction: alternate;\\n  -moz-animation-direction: alternate;\\n  -o-animation-direction: alternate;\\n  animation-direction: alternate;\\n  -webkit-animation-timing-function: ease-in-out;\\n  -moz-animation-timing-function: ease-in-out;\\n  -o-animation-timing-function: ease-in-out;\\n  animation-timing-function: ease-in-out;\\n  border: 0px;\\n}\\n.cyber-button {\\n  font-size: 28px;\\n  font-weight: bold;\\n  text-transform: uppercase;\\nwidth:100%;\\n  border: 1px solid var(--pink);\\n\\n  background-color: rgba(158, 7, 223, 0.919); /* sets the opacity to 0.7 */\\n  background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_0___ + \");\\n  background-size:cover;\\n  background-repeat:no-repeat;\\n  background-position:center;\\n  background-size:225%;\\n  color: transparent; /* makes the text transparent */\\n\\n\\n\\n  box-shadow: 0px 0px 20px 5px #ff0dcb;\\n  cursor:pointer;\\n}\\n.cyber-button-estates {\\n  font-size: 28px;\\n  font-weight: bold;\\n  text-transform: uppercase;\\nwidth:100%;\\n  border: 1px solid var(--pink);\\n\\n  background-color: rgba(158, 7, 223, 0.919); /* sets the opacity to 0.7 */\\n  background-image:url(\" + ___CSS_LOADER_URL_REPLACEMENT_1___ + \");\\n  background-size:cover;\\nbackground-position:center;\\n  background-repeat:no-repeat;\\n\\n\\n  color: transparent; /* makes the text transparent */\\n\\n\\n\\n  box-shadow: 0px 0px 20px 5px #ff0dcb;\\n  cursor:pointer;\\n}\\n.cyber-button:hover, .cyber-button-estates:hover {\\n  box-shadow: 0px 0px 30px 10px var(--pink);\\n  animation: cyber-glow 2s infinite;\\n  color: rgba(0, 0, 0, 0.2);\\n  -webkit-text-stroke: 1px var(--pink);\\n  border: 1px solid var(--pink);\\n  border-radius: 10%;\\n  background-repeat: no-repeat;\\n}\\n\\n@keyframes cyber-glow {\\n  0% {\\n    box-shadow: 0px 0px 10px 5px #ee0cb5;\\n  }\\n  50% {\\n    box-shadow: 0px 0px 30px 10px #ee0cb5;\\n  }\\n  100% {\\n    box-shadow: 0px 0px 10px 5px #ee0cb5;\\n  }\\n}\\n\\n.enter-cyberverse {\\n\\n\\n    margin-top:22%;\\n      display:flex;\\n     margin-right:65%;\\n     position:absolute;\\n    width:12.5REM;\\n    HEIGHT:10REM;\\n    \\n}\\n\\na#playgameoutline:hover {\\n  animation: cyber-glow 2s infinite;\\n}\\n\\n@media all and (max-width:40em){\\n.enter-cyberverse, div.enter-estate-container{\\n   width:25%;\\n   height:auto;\\n\\n  }\\n  .cyber-button, .cyber-button-estates {\\n    font-size:x-small;\\n    box-shadow: 0px 0px 30px 10px var(--pink);\\n    animation: cyber-glow 2s infinite;\\n    color: rgba(0, 0, 0, 0.2);\\n    -webkit-text-stroke: 1px var(--pink);\\n    border: 1px solid var(--pink);\\n    border-radius: 10%;\\n    background-repeat: no-repeat;\\n  }\\n\\n}\", \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nvar navLinks = document.querySelector('.nav-links');\nvar links = document.querySelectorAll('.nav-links li');\nvar menu = document.getElementsByClassName(\"navLinks\");\nvar scrollUp = document.getElementById(\"scrollTop\");\nvar mintButton = document.getElementById(\"mint-button\");\nvar auctionLink = document.getElementById(\"auction-link\");\nvar auctionUrl = \"https://www.skyharbor.io/collection/cybercitizens\";\nvar openMint = false;\nvar images = [\"./dist/assets/cybercitizens/0.png\", \"./dist/assets/cybercitizens/3.png\", \"./dist/assets/cybercitizens/590.png\", \".//dist/assets/cybercitizens/1873.png\", \"./dist/assets/cybercitizens/1852.png\", \"./dist/assets/cybercitizens/3.png\", \"./dist/assets/cybercitizens/7.png\", \"./dist/assets/cybercitizens/590.png\"];\nvar x = 0;\nif (scrollUp) {\n  scrollUp.addEventListener('click', function () {\n    window.scrollTo(0, 0);\n  });\n}\nvar faders = document.querySelectorAll(\".fade-in\");\nvar appearOptions = {\n  threshold: 0.1,\n  rootMargin: \"0px 0px -200px 0px\"\n};\nvar appearOnScroll = new IntersectionObserver(function (entries, displayOnScroll) {\n  entries.forEach(function (entry) {\n    if (!entry.isIntersecting) {\n      return;\n    } else {\n      entry.target.classList.add(\"appear\");\n      appearOnScroll.unobserve(entry.target);\n    }\n  });\n}, appearOptions);\nfaders.forEach(function (fader) {\n  appearOnScroll.observe(fader);\n});\ndocument.querySelector(\".address\").onclick = function () {\n  copyToClipboard(\"9hfNCyqJsCSku8HXrV17Y6AaQciCAwkwx4M49imdWjRaTX22Mvz\");\n  alert(\"Address copied to clipboard!\");\n};\nvar getUnsold = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return fetch(\"https://ergnomes-server.net/api/checkUnsold\").then(function (res) {\n            return res.json();\n          }).then(function (res) {\n            setupMint(res[\"count\"]);\n          })[\"catch\"](function (error) {\n            console.log(error);\n          });\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function getUnsold() {\n    return _ref.apply(this, arguments);\n  };\n}();\nvar setupMint = function setupMint(number) {\n  var numLeftWave;\n  if (openMint) {\n    numLeftWave = number - 500;\n    document.getElementById(\"unsold\").innerHTML = \"<span>\" + numLeftWave + \"</span> left in the current wave!\";\n  } else {\n    numLeftWave = number % 500;\n    if (numLeftWave != 0 || openMint) {\n      document.getElementById(\"unsold\").innerHTML = \"<span>\" + numLeftWave + \"</span> left in the current wave!\";\n    } else {\n      document.getElementById(\"unsold\").innerHTML = \"Wave sold out!\";\n      mintButton.innerText = \"Mint Closed\";\n      mintButton.href = \"javascript:void(0);\";\n    }\n  }\n};\nvar exitMenuOnLinkClick = function exitMenuOnLinkClick() {\n  navLinks.classList.toggle(\"open\");\n  links.forEach(function (link) {\n    link.classList.toggle(\"fade\");\n  });\n};\nvar displayNextImage = function displayNextImage() {\n  x = x === images.length - 1 ? 0 : x + 1;\n  document.getElementById(\"ergopixel-img\").src = images[x];\n};\nvar copyToClipboard = function copyToClipboard(text) {\n  navigator.clipboard.writeText(\"9eXCfrmgJSuYKS6hf32snZHZYCFvVeAsBU6LigaKkd5hzjUB3Rf\");\n};\nvar setAuctionLink = function setAuctionLink(link) {\n  auctionLink.href = link;\n};\ngetUnsold();\nsetAuctionLink(auctionUrl);\nsetInterval(displayNextImage, 500);\nvar modal = document.getElementById(\"mintModal\");\n\n// Get the button that opens the modal\nvar btn = document.getElementById(\"mint-button\");\n\n// Get the <span> element that closes the modal\nvar span = document.getElementsByClassName(\"close\")[0];\n\n// When the user clicks the button, open the modal \nbtn.onclick = function () {\n  modal.style.display = \"block\";\n};\n\n// When the user clicks on <span> (x), close the modal\nspan.onclick = function () {\n  modal.style.display = \"none\";\n};\n\n// When the user clicks anywhere outside of the modal, close it\nwindow.onclick = function (event) {\n  if (event.target == modal) {\n    modal.style.display = \"none\";\n  }\n};","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nimport { OutputBuilder, TransactionBuilder } from \"@fleet-sdk/core\";\nvar unsignedTransaction;\nfunction mint() {\n  return _mint.apply(this, arguments);\n}\nfunction _mint() {\n  _mint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n    var cypxTokenId, creationHeight, amountToSend, inputs, userAddress, cybercitizensWallet, requiredNanoErgs, requiredErgs;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.prev = 0;\n          cypxTokenId = \"01dce8a5632d19799950ff90bca3b5d0ca3ebfa8aaafd06f0cc6dd1e97150e7f\";\n          _context2.next = 4;\n          return ergo.get_current_height();\n        case 4:\n          creationHeight = _context2.sent;\n          amountToSend = 20000000000;\n          _context2.next = 8;\n          return ergo.get_utxos();\n        case 8:\n          inputs = _context2.sent;\n          _context2.next = 11;\n          return ergo.get_change_address();\n        case 11:\n          userAddress = _context2.sent;\n          cybercitizensWallet = \"9eXCfrmgJSuYKS6hf32snZHZYCFvVeAsBU6LigaKkd5hzjUB3Rf\";\n          unsignedTransaction = new TransactionBuilder(creationHeight).from(inputs).to(new OutputBuilder(amountToSend, cybercitizensWallet)).sendChangeTo(userAddress).payMinFee().build(\"EIP-12\");\n          console.log(\"Inputs:\", inputs);\n          console.log(\"Outputs:\", unsignedTransaction.outputs);\n          return _context2.abrupt(\"return\", unsignedTransaction);\n        case 19:\n          _context2.prev = 19;\n          _context2.t0 = _context2[\"catch\"](0);\n          console.error(\"Error minting coins: \".concat(_context2.t0));\n          if (_context2.t0.message.includes('>')) {\n            requiredNanoErgs = _context2.t0.message.match(/\\d+/)[0];\n            requiredErgs = requiredNanoErgs / Math.pow(10, 9) + 0.001;\n            alert(\"You do not have enough funds to complete this transaction, please add \".concat(requiredErgs.toFixed(4), \" ERG\"));\n          } else if (_context2.t0.message.includes('not defined')) {\n            alert('Please connect your wallet');\n          } else {\n            alert(\"Error minting coins: \".concat(_context2.t0));\n          }\n        case 23:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[0, 19]]);\n  }));\n  return _mint.apply(this, arguments);\n}\nvar mintbtn = document.getElementById(\"mintbtn\");\nvar mintbtnText = mintbtn.innerText;\nmintbtn.addEventListener(\"click\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n  var _unsignedTransaction, signedTransaction, txId;\n  return _regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        _context.prev = 0;\n        mintbtn.disabled = true;\n        mintbtn.classList.add(\"disabled\");\n        mintbtn.innerHTML = \"<span class=\\\"spinner-border spinner-border-sm\\\" role=\\\"status\\\" aria-hidden=\\\"true\\\"></span> Please wait while the transaction is being built...\";\n        _context.next = 6;\n        return mint();\n      case 6:\n        _unsignedTransaction = _context.sent;\n        if (!_unsignedTransaction) {\n          _context.next = 18;\n          break;\n        }\n        console.log(\"Unsigned Transaction:\", _unsignedTransaction);\n        _context.next = 11;\n        return ergo.sign_tx(_unsignedTransaction);\n      case 11:\n        signedTransaction = _context.sent;\n        console.log(\"Signed Transaction:\", signedTransaction);\n        _context.next = 15;\n        return ergo.submit_tx(signedTransaction);\n      case 15:\n        txId = _context.sent;\n        console.log(txId);\n        alert(\"Transaction submitted. TX ID: \".concat(txId));\n      case 18:\n        _context.next = 24;\n        break;\n      case 20:\n        _context.prev = 20;\n        _context.t0 = _context[\"catch\"](0);\n        console.error(\"Error minting coins: \".concat(_context.t0));\n        alert(\"Error minting coins: \".concat(_context.t0));\n      case 24:\n        _context.prev = 24;\n        mintbtn.disabled = false;\n        mintbtn.classList.remove(\"disabled\");\n        mintbtn.innerText = mintbtnText;\n        return _context.finish(24);\n      case 29:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _callee, null, [[0, 20, 24, 29]]);\n})));\n\n// Add an event listener for beforeunload event\nwindow.addEventListener(\"beforeunload\", function () {\n  // Check if mintbtn is disabled, and re-enable it\n  if (mintbtn.disabled) {\n    mintbtn.disabled = false;\n    mintbtn.classList.remove(\"disabled\");\n    mintbtn.innerText = mintbtnText;\n  }\n});","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { isUndefined, Network } from \"@fleet-sdk/common\";\nimport { _0n, chunk, ensureBigInt, isDefined, isHex, some, utxoSum } from \"@fleet-sdk/common\";\nimport { InvalidInput, MalformedTransaction, NotAllowedTokenBurning } from \"../errors\";\nimport { NonStandardizedMinting } from \"../errors/nonStandardizedMinting\";\nimport { ErgoAddress, InputsCollection, OutputsCollection, TokensCollection } from \"../models\";\nimport { OutputBuilder, SAFE_MIN_BOX_VALUE } from \"./outputBuilder\";\nimport { createPluginContext } from \"./pluginContext\";\nimport { BoxSelector } from \"./selector\";\nimport { TransactionBuilderSettings } from \"./transactionBuilderSettings\";\nexport var RECOMMENDED_MIN_FEE_VALUE = BigInt(1100000);\nexport var FEE_CONTRACT = \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\";\nexport var TransactionBuilder = /*#__PURE__*/function () {\n  function TransactionBuilder(creationHeight) {\n    _classCallCheck(this, TransactionBuilder);\n    _defineProperty(this, \"_inputs\", void 0);\n    _defineProperty(this, \"_dataInputs\", void 0);\n    _defineProperty(this, \"_outputs\", void 0);\n    _defineProperty(this, \"_settings\", void 0);\n    _defineProperty(this, \"_creationHeight\", void 0);\n    _defineProperty(this, \"_selectorCallbacks\", void 0);\n    _defineProperty(this, \"_changeAddress\", void 0);\n    _defineProperty(this, \"_feeAmount\", void 0);\n    _defineProperty(this, \"_burning\", void 0);\n    _defineProperty(this, \"_plugins\", void 0);\n    this._inputs = new InputsCollection();\n    this._dataInputs = new InputsCollection();\n    this._outputs = new OutputsCollection();\n    this._settings = new TransactionBuilderSettings();\n    this._creationHeight = creationHeight;\n  }\n  _createClass(TransactionBuilder, [{\n    key: \"inputs\",\n    get: function get() {\n      return this._inputs;\n    }\n  }, {\n    key: \"dataInputs\",\n    get: function get() {\n      return this._dataInputs;\n    }\n  }, {\n    key: \"outputs\",\n    get: function get() {\n      return this._outputs;\n    }\n  }, {\n    key: \"changeAddress\",\n    get: function get() {\n      return this._changeAddress;\n    }\n  }, {\n    key: \"fee\",\n    get: function get() {\n      return this._feeAmount;\n    }\n  }, {\n    key: \"burning\",\n    get: function get() {\n      return this._burning;\n    }\n  }, {\n    key: \"settings\",\n    get: function get() {\n      return this._settings;\n    }\n  }, {\n    key: \"creationHeight\",\n    get: function get() {\n      return this._creationHeight;\n    }\n    /**\n     * Syntax sugar to be used in composition with another methods\n     *\n     * @example\n     * ```\n     * new TransactionBuilder(height)\n     *   .from(inputs)\n     *   .and.from(otherInputs);\n     * ```\n     */\n  }, {\n    key: \"and\",\n    get: function get() {\n      return this;\n    }\n  }, {\n    key: \"from\",\n    value: function from(inputs) {\n      this._inputs.add(inputs);\n      return this;\n    }\n  }, {\n    key: \"to\",\n    value: function to(outputs, options) {\n      this._outputs.add(outputs, options);\n      return this;\n    }\n  }, {\n    key: \"withDataFrom\",\n    value: function withDataFrom(dataInputs, options) {\n      this._dataInputs.add(dataInputs, options);\n      return this;\n    }\n  }, {\n    key: \"sendChangeTo\",\n    value: function sendChangeTo(address) {\n      if (typeof address === \"string\") {\n        this._changeAddress = isHex(address) ? ErgoAddress.fromErgoTree(address, Network.Mainnet) : ErgoAddress.fromBase58(address);\n      } else {\n        this._changeAddress = address;\n      }\n      return this;\n    }\n  }, {\n    key: \"payFee\",\n    value: function payFee(amount) {\n      this._feeAmount = ensureBigInt(amount);\n      return this;\n    }\n  }, {\n    key: \"payMinFee\",\n    value: function payMinFee() {\n      this.payFee(RECOMMENDED_MIN_FEE_VALUE);\n      return this;\n    }\n  }, {\n    key: \"burnTokens\",\n    value: function burnTokens(tokens) {\n      if (!this._burning) {\n        this._burning = new TokensCollection();\n      }\n      this._burning.add(tokens);\n      return this;\n    }\n  }, {\n    key: \"configure\",\n    value: function configure(callback) {\n      callback(this._settings);\n      return this;\n    }\n  }, {\n    key: \"configureSelector\",\n    value: function configureSelector(selectorCallback) {\n      if (isUndefined(this._selectorCallbacks)) {\n        this._selectorCallbacks = [];\n      }\n      this._selectorCallbacks.push(selectorCallback);\n      return this;\n    }\n  }, {\n    key: \"extend\",\n    value: function extend(plugins) {\n      if (!this._plugins) {\n        this._plugins = [];\n      }\n      this._plugins.push({\n        execute: plugins,\n        pending: true\n      });\n      return this;\n    }\n  }, {\n    key: \"eject\",\n    value: function eject(ejector) {\n      var _this = this;\n      ejector({\n        inputs: this.inputs,\n        dataInputs: this.dataInputs,\n        outputs: this.outputs,\n        burning: this.burning,\n        settings: this.settings,\n        selection: function selection(selectorCallback) {\n          _this.configureSelector(selectorCallback);\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function build(buildOutputType) {\n      var _this2 = this;\n      if (some(this._plugins)) {\n        var context = createPluginContext(this);\n        var _iterator = _createForOfIteratorHelper(this._plugins),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var plugin = _step.value;\n            if (plugin.pending) {\n              plugin.execute(context);\n              plugin.pending = false;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      if (this._isMinting()) {\n        if (this._isMoreThanOneTokenBeingMinted()) {\n          throw new MalformedTransaction(\"only one token can be minted per transaction.\");\n        }\n        if (this._isTheSameTokenBeingMintedOutsideTheMintingBox()) {\n          throw new NonStandardizedMinting(\"EIP-4 tokens cannot be minted from outside the minting box.\");\n        }\n      }\n      var outputs = this.outputs.clone();\n      if (isDefined(this._feeAmount)) {\n        outputs.add(new OutputBuilder(this._feeAmount, FEE_CONTRACT));\n      }\n      var selector = new BoxSelector(this.inputs.toArray());\n      if (some(this._selectorCallbacks)) {\n        var _iterator2 = _createForOfIteratorHelper(this._selectorCallbacks),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var selectorCallBack = _step2.value;\n            selectorCallBack(selector);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      var target = some(this._burning) ? outputs.sum({\n        tokens: this._burning.toArray()\n      }) : outputs.sum();\n      var inputs = selector.select(target);\n      if (isDefined(this._changeAddress)) {\n        var change = this._calcDiff(utxoSum(inputs), target);\n        if (some(change.tokens)) {\n          var requiredNanoErgs = this._calcRequiredNanoErgsForChange(change.tokens.length);\n          while (requiredNanoErgs > change.nanoErgs) {\n            inputs = selector.select({\n              nanoErgs: target.nanoErgs + requiredNanoErgs,\n              tokens: target.tokens\n            });\n            change = this._calcDiff(utxoSum(inputs), target);\n            requiredNanoErgs = this._calcRequiredNanoErgsForChange(change.tokens.length);\n          }\n          var chunkedTokens = chunk(change.tokens, this._settings.maxTokensPerChangeBox);\n          var _iterator3 = _createForOfIteratorHelper(chunkedTokens),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var tokens = _step3.value;\n              var nanoErgs = change.nanoErgs > requiredNanoErgs ? change.nanoErgs - requiredNanoErgs + SAFE_MIN_BOX_VALUE : SAFE_MIN_BOX_VALUE;\n              change.nanoErgs -= nanoErgs;\n              outputs.add(new OutputBuilder(nanoErgs, this._changeAddress).addTokens(tokens));\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n        if (change.nanoErgs > _0n) {\n          outputs.add(new OutputBuilder(change.nanoErgs, this._changeAddress));\n        }\n      }\n      var _iterator4 = _createForOfIteratorHelper(inputs),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var input = _step4.value;\n          if (!input.isValid()) {\n            throw new InvalidInput(input.boxId);\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      var unsignedTransaction = {\n        inputs: inputs.map(function (input) {\n          return input.toUnsignedInputObject(buildOutputType || \"default\");\n        }),\n        dataInputs: this.dataInputs.toArray().map(function (input) {\n          return input.toObject(buildOutputType || \"default\");\n        }),\n        outputs: outputs.toArray().map(function (output) {\n          return output.setCreationHeight(_this2._creationHeight, {\n            replace: false\n          }).build(inputs);\n        })\n      };\n      var burning = this._calcBurningBalance(unsignedTransaction, inputs);\n      if (burning.nanoErgs > _0n) {\n        throw new MalformedTransaction(\"it's not possible to burn ERG.\");\n      }\n      if (some(burning.tokens) && some(this._burning)) {\n        burning = this._calcDiff(burning, {\n          nanoErgs: _0n,\n          tokens: this._burning.toArray()\n        });\n      }\n      if (!this._settings.canBurnTokens && some(burning.tokens)) {\n        throw new NotAllowedTokenBurning();\n      }\n      return unsignedTransaction;\n    }\n  }, {\n    key: \"_isMinting\",\n    value: function _isMinting() {\n      var _iterator5 = _createForOfIteratorHelper(this._outputs),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var output = _step5.value;\n          if (output.minting) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"_isMoreThanOneTokenBeingMinted\",\n    value: function _isMoreThanOneTokenBeingMinted() {\n      var mintingCount = 0;\n      var _iterator6 = _createForOfIteratorHelper(this._outputs),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var output = _step6.value;\n          if (isDefined(output.minting)) {\n            mintingCount++;\n            if (mintingCount > 1) {\n              return true;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"_isTheSameTokenBeingMintedOutsideTheMintingBox\",\n    value: function _isTheSameTokenBeingMintedOutsideTheMintingBox() {\n      var mintingTokenId = this._getMintingTokenId();\n      if (isUndefined(mintingTokenId)) {\n        return false;\n      }\n      var _iterator7 = _createForOfIteratorHelper(this._outputs),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var output = _step7.value;\n          if (output.tokens.contains(mintingTokenId)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"_getMintingTokenId\",\n    value: function _getMintingTokenId() {\n      var tokenId = undefined;\n      var _iterator8 = _createForOfIteratorHelper(this._outputs),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var output = _step8.value;\n          if (output.minting) {\n            tokenId = output.minting.tokenId;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      return tokenId;\n    }\n  }, {\n    key: \"_calcBurningBalance\",\n    value: function _calcBurningBalance(unsignedTransaction, inputs) {\n      var usedInputs = inputs.filter(function (input) {\n        return isDefined(unsignedTransaction.inputs.find(function (txInput) {\n          return txInput.boxId === input.boxId;\n        }));\n      });\n      return this._calcDiff(utxoSum(usedInputs), utxoSum(unsignedTransaction.outputs));\n    }\n  }, {\n    key: \"_calcChangeLength\",\n    value: function _calcChangeLength(tokensLength) {\n      return Math.ceil(tokensLength / this._settings.maxTokensPerChangeBox);\n    }\n  }, {\n    key: \"_calcRequiredNanoErgsForChange\",\n    value: function _calcRequiredNanoErgsForChange(tokensLength) {\n      var minNanoErgsPerBox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SAFE_MIN_BOX_VALUE;\n      return minNanoErgsPerBox * BigInt(this._calcChangeLength(tokensLength));\n    }\n  }, {\n    key: \"_calcDiff\",\n    value: function _calcDiff(inputs, outputs) {\n      var tokens = [];\n      var nanoErgs = inputs.nanoErgs - outputs.nanoErgs;\n      var _iterator9 = _createForOfIteratorHelper(inputs.tokens),\n        _step9;\n      try {\n        var _loop = function _loop() {\n          var _outputs$tokens$find;\n          var token = _step9.value;\n          var balance = token.amount - (((_outputs$tokens$find = outputs.tokens.find(function (t) {\n            return t.tokenId === token.tokenId;\n          })) === null || _outputs$tokens$find === void 0 ? void 0 : _outputs$tokens$find.amount) || _0n);\n          if (balance > _0n) {\n            tokens.push({\n              tokenId: token.tokenId,\n              amount: balance\n            });\n          }\n        };\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      return {\n        nanoErgs: nanoErgs,\n        tokens: tokens\n      };\n    }\n  }]);\n  return TransactionBuilder;\n}();","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nimport { isDefined } from \"@fleet-sdk/common\";\nimport { DuplicateInputError, NotFoundError } from \"../../errors\";\nimport { ErgoUnsignedInput } from \"../ergoUnsignedInput\";\nimport { Collection } from \"./collection\";\nexport var InputsCollection = /*#__PURE__*/function (_Collection) {\n  _inherits(InputsCollection, _Collection);\n  var _super = _createSuper(InputsCollection);\n  function InputsCollection(boxes) {\n    var _this;\n    _classCallCheck(this, InputsCollection);\n    _this = _super.call(this);\n    if (isDefined(boxes)) {\n      _this.add(boxes);\n    }\n    return _this;\n  }\n  _createClass(InputsCollection, [{\n    key: \"_map\",\n    value: function _map(input) {\n      return input instanceof ErgoUnsignedInput ? input : new ErgoUnsignedInput(input);\n    }\n  }, {\n    key: \"_addOne\",\n    value: function _addOne(box) {\n      if (this._items.some(function (item) {\n        return item.boxId === box.boxId;\n      })) {\n        throw new DuplicateInputError(box.boxId);\n      }\n      return _get(_getPrototypeOf(InputsCollection.prototype), \"_addOne\", this).call(this, box);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(boxIdOrIndex) {\n      var index = -1;\n      if (typeof boxIdOrIndex === \"number\") {\n        if (this._isIndexOutOfBounds(boxIdOrIndex)) {\n          throw new RangeError(\"Index '\".concat(boxIdOrIndex, \"' is out of range.\"));\n        }\n        index = boxIdOrIndex;\n      } else {\n        index = this._items.findIndex(function (box) {\n          return box.boxId === boxIdOrIndex;\n        });\n        if (this._isIndexOutOfBounds(index)) {\n          throw new NotFoundError(\"The input you are trying to remove is not present in the inputs collection.\");\n        }\n      }\n      if (index > -1) {\n        this._items.splice(index, 1);\n      }\n      return this.length;\n    }\n  }]);\n  return InputsCollection;\n}(Collection);","export function removeUndefined(value) {\n  var result = {};\n  for (var key in value) {\n    var val = value[key];\n    if (!isUndefined(val)) {\n      result[key] = val;\n    }\n  }\n  return result;\n}\nexport function isUndefined(value) {\n  return value === undefined || value === null || Number.isNaN(value);\n}\nexport function isDefined(value) {\n  return !isUndefined(value);\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { ErgoBox } from \"./ergoBox\";\nexport var ErgoUnsignedInput = /*#__PURE__*/function (_ErgoBox) {\n  _inherits(ErgoUnsignedInput, _ErgoBox);\n  var _super = _createSuper(ErgoUnsignedInput);\n  function ErgoUnsignedInput(box) {\n    var _this;\n    _classCallCheck(this, ErgoUnsignedInput);\n    _this = _super.call(this, box);\n    _defineProperty(_assertThisInitialized(_this), \"_extension\", void 0);\n    return _this;\n  }\n  _createClass(ErgoUnsignedInput, [{\n    key: \"extension\",\n    get: function get() {\n      return this._extension;\n    }\n  }, {\n    key: \"setContextVars\",\n    value: function setContextVars(extension) {\n      this._extension = extension;\n      return this;\n    }\n  }, {\n    key: \"toUnsignedInputObject\",\n    value: function toUnsignedInputObject(type) {\n      return _objectSpread(_objectSpread({}, this.toObject(type)), {}, {\n        extension: this._extension || {}\n      });\n    }\n  }, {\n    key: \"toObject\",\n    value: function toObject(type) {\n      if (type === \"EIP-12\") {\n        return {\n          boxId: this.boxId,\n          value: this.value.toString(),\n          ergoTree: this.ergoTree,\n          creationHeight: this.creationHeight,\n          assets: this.assets.map(function (asset) {\n            return {\n              tokenId: asset.tokenId,\n              amount: asset.amount.toString()\n            };\n          }),\n          additionalRegisters: this.additionalRegisters,\n          transactionId: this.transactionId,\n          index: this.index\n        };\n      } else {\n        return {\n          boxId: this.boxId\n        };\n      }\n    }\n  }]);\n  return ErgoUnsignedInput;\n}(ErgoBox);","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { ensureBigInt } from \"@fleet-sdk/common\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport { serializeBox } from \"../serializer/sigma/boxSerializer\";\nexport var ErgoBox = /*#__PURE__*/function () {\n  function ErgoBox(box) {\n    _classCallCheck(this, ErgoBox);\n    _defineProperty(this, \"boxId\", void 0);\n    _defineProperty(this, \"value\", void 0);\n    _defineProperty(this, \"ergoTree\", void 0);\n    _defineProperty(this, \"creationHeight\", void 0);\n    _defineProperty(this, \"assets\", void 0);\n    _defineProperty(this, \"additionalRegisters\", void 0);\n    _defineProperty(this, \"transactionId\", void 0);\n    _defineProperty(this, \"index\", void 0);\n    this.boxId = box.boxId;\n    this.ergoTree = box.ergoTree;\n    this.creationHeight = box.creationHeight;\n    this.value = ensureBigInt(box.value);\n    this.assets = box.assets.map(function (asset) {\n      return {\n        tokenId: asset.tokenId,\n        amount: ensureBigInt(asset.amount)\n      };\n    });\n    this.additionalRegisters = box.additionalRegisters;\n    this.transactionId = box.transactionId;\n    this.index = box.index;\n  }\n  _createClass(ErgoBox, [{\n    key: \"isValid\",\n    value: function isValid() {\n      return ErgoBox.validate(this);\n    }\n  }], [{\n    key: \"validate\",\n    value: function validate(box) {\n      var bytes = serializeBox(box);\n      var hash = bytesToHex(blake2b(bytes, {\n        dkLen: 32\n      }));\n      return box.boxId === hash;\n    }\n  }]);\n  return ErgoBox;\n}();","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nimport { BLAKE2, SIGMA } from './_blake2.js';\nimport u64 from './_u64.js';\nimport { toBytes, u32, wrapConstructorWithOpts } from './utils.js';\n// Same as SHA-512 but LE\n// prettier-ignore\nvar IV = new Uint32Array([0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372, 0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c, 0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19]);\n// Temporary buffer\nvar BUF = new Uint32Array(32);\n// Mixing function G splitted in two halfs\nfunction G1(a, b, c, d, msg, x) {\n  // NOTE: V is LE here\n  var Xl = msg[x],\n    Xh = msg[x + 1]; // prettier-ignore\n  var Al = BUF[2 * a],\n    Ah = BUF[2 * a + 1]; // prettier-ignore\n  var Bl = BUF[2 * b],\n    Bh = BUF[2 * b + 1]; // prettier-ignore\n  var Cl = BUF[2 * c],\n    Ch = BUF[2 * c + 1]; // prettier-ignore\n  var Dl = BUF[2 * d],\n    Dh = BUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  var ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 32)\n  var _Dh$Dl = {\n    Dh: Dh ^ Ah,\n    Dl: Dl ^ Al\n  };\n  Dh = _Dh$Dl.Dh;\n  Dl = _Dh$Dl.Dl;\n  var _Dh$Dl2 = {\n    Dh: u64.rotr32H(Dh, Dl),\n    Dl: u64.rotr32L(Dh, Dl)\n  };\n  Dh = _Dh$Dl2.Dh;\n  Dl = _Dh$Dl2.Dl;\n  var _u64$add = u64.add(Ch, Cl, Dh, Dl);\n  Ch = _u64$add.h;\n  Cl = _u64$add.l;\n  var _Bh$Bl = {\n    Bh: Bh ^ Ch,\n    Bl: Bl ^ Cl\n  };\n  Bh = _Bh$Bl.Bh;\n  Bl = _Bh$Bl.Bl;\n  var _Bh$Bl2 = {\n    Bh: u64.rotrSH(Bh, Bl, 24),\n    Bl: u64.rotrSL(Bh, Bl, 24)\n  };\n  Bh = _Bh$Bl2.Bh;\n  Bl = _Bh$Bl2.Bl;\n  BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;\n  BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;\n  BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;\n  BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;\n}\nfunction G2(a, b, c, d, msg, x) {\n  // NOTE: V is LE here\n  var Xl = msg[x],\n    Xh = msg[x + 1]; // prettier-ignore\n  var Al = BUF[2 * a],\n    Ah = BUF[2 * a + 1]; // prettier-ignore\n  var Bl = BUF[2 * b],\n    Bh = BUF[2 * b + 1]; // prettier-ignore\n  var Cl = BUF[2 * c],\n    Ch = BUF[2 * c + 1]; // prettier-ignore\n  var Dl = BUF[2 * d],\n    Dh = BUF[2 * d + 1]; // prettier-ignore\n  // v[a] = (v[a] + v[b] + x) | 0;\n  var ll = u64.add3L(Al, Bl, Xl);\n  Ah = u64.add3H(ll, Ah, Bh, Xh);\n  Al = ll | 0;\n  // v[d] = rotr(v[d] ^ v[a], 16)\n  var _Dh$Dl3 = {\n    Dh: Dh ^ Ah,\n    Dl: Dl ^ Al\n  };\n  Dh = _Dh$Dl3.Dh;\n  Dl = _Dh$Dl3.Dl;\n  var _Dh$Dl4 = {\n    Dh: u64.rotrSH(Dh, Dl, 16),\n    Dl: u64.rotrSL(Dh, Dl, 16)\n  };\n  Dh = _Dh$Dl4.Dh;\n  Dl = _Dh$Dl4.Dl;\n  var _u64$add2 = u64.add(Ch, Cl, Dh, Dl);\n  Ch = _u64$add2.h;\n  Cl = _u64$add2.l;\n  var _Bh$Bl3 = {\n    Bh: Bh ^ Ch,\n    Bl: Bl ^ Cl\n  };\n  Bh = _Bh$Bl3.Bh;\n  Bl = _Bh$Bl3.Bl;\n  var _Bh$Bl4 = {\n    Bh: u64.rotrBH(Bh, Bl, 63),\n    Bl: u64.rotrBL(Bh, Bl, 63)\n  };\n  Bh = _Bh$Bl4.Bh;\n  Bl = _Bh$Bl4.Bl;\n  BUF[2 * a] = Al, BUF[2 * a + 1] = Ah;\n  BUF[2 * b] = Bl, BUF[2 * b + 1] = Bh;\n  BUF[2 * c] = Cl, BUF[2 * c + 1] = Ch;\n  BUF[2 * d] = Dl, BUF[2 * d + 1] = Dh;\n}\nvar BLAKE2b = /*#__PURE__*/function (_BLAKE) {\n  _inherits(BLAKE2b, _BLAKE);\n  var _super = _createSuper(BLAKE2b);\n  function BLAKE2b() {\n    var _this;\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, BLAKE2b);\n    _this = _super.call(this, 128, opts.dkLen === undefined ? 64 : opts.dkLen, opts, 64, 16, 16);\n    // Same as SHA-512, but LE\n    _this.v0l = IV[0] | 0;\n    _this.v0h = IV[1] | 0;\n    _this.v1l = IV[2] | 0;\n    _this.v1h = IV[3] | 0;\n    _this.v2l = IV[4] | 0;\n    _this.v2h = IV[5] | 0;\n    _this.v3l = IV[6] | 0;\n    _this.v3h = IV[7] | 0;\n    _this.v4l = IV[8] | 0;\n    _this.v4h = IV[9] | 0;\n    _this.v5l = IV[10] | 0;\n    _this.v5h = IV[11] | 0;\n    _this.v6l = IV[12] | 0;\n    _this.v6h = IV[13] | 0;\n    _this.v7l = IV[14] | 0;\n    _this.v7h = IV[15] | 0;\n    var keyLength = opts.key ? opts.key.length : 0;\n    _this.v0l ^= _this.outputLen | keyLength << 8 | 0x01 << 16 | 0x01 << 24;\n    if (opts.salt) {\n      var salt = u32(toBytes(opts.salt));\n      _this.v4l ^= salt[0];\n      _this.v4h ^= salt[1];\n      _this.v5l ^= salt[2];\n      _this.v5h ^= salt[3];\n    }\n    if (opts.personalization) {\n      var pers = u32(toBytes(opts.personalization));\n      _this.v6l ^= pers[0];\n      _this.v6h ^= pers[1];\n      _this.v7l ^= pers[2];\n      _this.v7h ^= pers[3];\n    }\n    if (opts.key) {\n      // Pad to blockLen and update\n      var tmp = new Uint8Array(_this.blockLen);\n      tmp.set(toBytes(opts.key));\n      _this.update(tmp);\n    }\n    return _this;\n  }\n  // prettier-ignore\n  _createClass(BLAKE2b, [{\n    key: \"get\",\n    value: function get() {\n      var v0l = this.v0l,\n        v0h = this.v0h,\n        v1l = this.v1l,\n        v1h = this.v1h,\n        v2l = this.v2l,\n        v2h = this.v2h,\n        v3l = this.v3l,\n        v3h = this.v3h,\n        v4l = this.v4l,\n        v4h = this.v4h,\n        v5l = this.v5l,\n        v5h = this.v5h,\n        v6l = this.v6l,\n        v6h = this.v6h,\n        v7l = this.v7l,\n        v7h = this.v7h;\n      return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];\n    }\n    // prettier-ignore\n  }, {\n    key: \"set\",\n    value: function set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {\n      this.v0l = v0l | 0;\n      this.v0h = v0h | 0;\n      this.v1l = v1l | 0;\n      this.v1h = v1h | 0;\n      this.v2l = v2l | 0;\n      this.v2h = v2h | 0;\n      this.v3l = v3l | 0;\n      this.v3h = v3h | 0;\n      this.v4l = v4l | 0;\n      this.v4h = v4h | 0;\n      this.v5l = v5l | 0;\n      this.v5h = v5h | 0;\n      this.v6l = v6l | 0;\n      this.v6h = v6h | 0;\n      this.v7l = v7l | 0;\n      this.v7h = v7h | 0;\n    }\n  }, {\n    key: \"compress\",\n    value: function compress(msg, offset, isLast) {\n      this.get().forEach(function (v, i) {\n        return BUF[i] = v;\n      }); // First half from state.\n      BUF.set(IV, 16); // Second half from IV.\n      var _u64$fromBig = u64.fromBig(BigInt(this.length)),\n        h = _u64$fromBig.h,\n        l = _u64$fromBig.l;\n      BUF[24] = IV[8] ^ l; // Low word of the offset.\n      BUF[25] = IV[9] ^ h; // High word.\n      // Invert all bits for last block\n      if (isLast) {\n        BUF[28] = ~BUF[28];\n        BUF[29] = ~BUF[29];\n      }\n      var j = 0;\n      var s = SIGMA;\n      for (var i = 0; i < 12; i++) {\n        G1(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n        G2(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n        G1(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n        G2(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n        G1(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n        G2(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n        G1(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n        G2(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n        G1(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n        G2(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n        G1(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n        G2(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n        G1(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n        G2(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n        G1(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n        G2(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n      }\n      this.v0l ^= BUF[0] ^ BUF[16];\n      this.v0h ^= BUF[1] ^ BUF[17];\n      this.v1l ^= BUF[2] ^ BUF[18];\n      this.v1h ^= BUF[3] ^ BUF[19];\n      this.v2l ^= BUF[4] ^ BUF[20];\n      this.v2h ^= BUF[5] ^ BUF[21];\n      this.v3l ^= BUF[6] ^ BUF[22];\n      this.v3h ^= BUF[7] ^ BUF[23];\n      this.v4l ^= BUF[8] ^ BUF[24];\n      this.v4h ^= BUF[9] ^ BUF[25];\n      this.v5l ^= BUF[10] ^ BUF[26];\n      this.v5h ^= BUF[11] ^ BUF[27];\n      this.v6l ^= BUF[12] ^ BUF[28];\n      this.v6h ^= BUF[13] ^ BUF[29];\n      this.v7l ^= BUF[14] ^ BUF[30];\n      this.v7h ^= BUF[15] ^ BUF[31];\n      BUF.fill(0);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.destroyed = true;\n      this.buffer32.fill(0);\n      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n  }]);\n  return BLAKE2b;\n}(BLAKE2);\n/**\n * BLAKE2b - optimized for 64-bit platforms. JS doesn't have uint64, so it's slower than BLAKE2s.\n * @param msg - message that would be hashed\n * @param opts - dkLen, key, salt, personalization\n */\nexport var blake2b = wrapConstructorWithOpts(function (opts) {\n  return new BLAKE2b(opts);\n});","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nimport assert from './_assert.js';\nimport { Hash, toBytes, u32 } from './utils.js';\n// prettier-ignore\nexport var SIGMA = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n// For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3]);\nexport var BLAKE2 = /*#__PURE__*/function (_Hash) {\n  _inherits(BLAKE2, _Hash);\n  var _super = _createSuper(BLAKE2);\n  function BLAKE2(blockLen, outputLen) {\n    var _this;\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var keyLen = arguments.length > 3 ? arguments[3] : undefined;\n    var saltLen = arguments.length > 4 ? arguments[4] : undefined;\n    var persLen = arguments.length > 5 ? arguments[5] : undefined;\n    _classCallCheck(this, BLAKE2);\n    _this = _super.call(this);\n    _this.blockLen = blockLen;\n    _this.outputLen = outputLen;\n    _this.length = 0;\n    _this.pos = 0;\n    _this.finished = false;\n    _this.destroyed = false;\n    assert.number(blockLen);\n    assert.number(outputLen);\n    assert.number(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error('Blake2: outputLen bigger than keyLen');\n    if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen)) throw new Error(\"Key should be up 1..\".concat(keyLen, \" byte long or undefined\"));\n    if (opts.salt !== undefined && opts.salt.length !== saltLen) throw new Error(\"Salt should be \".concat(saltLen, \" byte long or undefined\"));\n    if (opts.personalization !== undefined && opts.personalization.length !== persLen) throw new Error(\"Personalization should be \".concat(persLen, \" byte long or undefined\"));\n    _this.buffer32 = u32(_this.buffer = new Uint8Array(blockLen));\n    return _this;\n  }\n  _createClass(BLAKE2, [{\n    key: \"update\",\n    value: function update(data) {\n      assert.exists(this);\n      // Main difference with other hashes: there is flag for last block,\n      // so we cannot process current block before we know that there\n      // is the next one. This significantly complicates logic and reduces ability\n      // to do zero-copy processing\n      var blockLen = this.blockLen,\n        buffer = this.buffer,\n        buffer32 = this.buffer32;\n      data = toBytes(data);\n      var len = data.length;\n      for (var pos = 0; pos < len;) {\n        // If buffer is full and we still have input (don't process last block, same as blake2s)\n        if (this.pos === blockLen) {\n          this.compress(buffer32, 0, false);\n          this.pos = 0;\n        }\n        var take = Math.min(blockLen - this.pos, len - pos);\n        var dataOffset = data.byteOffset + pos;\n        // full block && aligned to 4 bytes && not last in input\n        if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n          var data32 = new Uint32Array(data.buffer, dataOffset, Math.floor((len - pos) / 4));\n          for (var pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n            this.length += blockLen;\n            this.compress(data32, pos32, false);\n          }\n          continue;\n        }\n        buffer.set(data.subarray(pos, pos + take), this.pos);\n        this.pos += take;\n        this.length += take;\n        pos += take;\n      }\n      return this;\n    }\n  }, {\n    key: \"digestInto\",\n    value: function digestInto(out) {\n      assert.exists(this);\n      assert.output(out, this);\n      var pos = this.pos,\n        buffer32 = this.buffer32;\n      this.finished = true;\n      // Padding\n      this.buffer.subarray(pos).fill(0);\n      this.compress(buffer32, 0, true);\n      var out32 = u32(out);\n      this.get().forEach(function (v, i) {\n        return out32[i] = v;\n      });\n    }\n  }, {\n    key: \"digest\",\n    value: function digest() {\n      var buffer = this.buffer,\n        outputLen = this.outputLen;\n      this.digestInto(buffer);\n      var res = buffer.slice(0, outputLen);\n      this.destroy();\n      return res;\n    }\n  }, {\n    key: \"_cloneInto\",\n    value: function _cloneInto(to) {\n      var _to;\n      var buffer = this.buffer,\n        length = this.length,\n        finished = this.finished,\n        destroyed = this.destroyed,\n        outputLen = this.outputLen,\n        pos = this.pos;\n      to || (to = new this.constructor({\n        dkLen: outputLen\n      }));\n      (_to = to).set.apply(_to, _toConsumableArray(this.get()));\n      to.length = length;\n      to.finished = finished;\n      to.destroyed = destroyed;\n      to.outputLen = outputLen;\n      to.buffer.set(buffer);\n      to.pos = pos;\n      return to;\n    }\n  }]);\n  return BLAKE2;\n}(Hash);","export function number(n) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"Wrong positive integer: \".concat(n));\n}\nexport function bool(b) {\n  if (typeof b !== 'boolean') throw new Error(\"Expected boolean, not \".concat(b));\n}\nexport function bytes(b) {\n  if (!(b instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');\n  for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    lengths[_key - 1] = arguments[_key];\n  }\n  if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError(\"Expected Uint8Array of length \".concat(lengths, \", not of length=\").concat(b.length));\n}\nexport function hash(hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\nexport function exists(instance) {\n  var checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nexport function output(out, instance) {\n  bytes(out);\n  var min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(\"digestInto() expects output buffer of length at least \".concat(min));\n  }\n}\nvar assert = {\n  number: number,\n  bool: bool,\n  bytes: bytes,\n  hash: hash,\n  exists: exists,\n  output: output\n};\nexport default assert;","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// The import here is via the package name. This is to ensure\n// that exports mapping/resolution does fall into place.\nimport { crypto } from '@noble/hashes/crypto';\n// Cast array to different type\nexport var u8 = function u8(arr) {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n};\nexport var u32 = function u32(arr) {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n};\n// Cast array to view\nexport var createView = function createView(arr) {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n};\n// The rotate right (circular right shift) operation for uint32\nexport var rotr = function rotr(word, shift) {\n  return word << 32 - shift | word >>> shift;\n};\nexport var isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.\n// So, just to be sure not to corrupt anything.\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\nvar hexes = Array.from({\n  length: 256\n}, function (v, i) {\n  return i.toString(16).padStart(2, '0');\n});\n/**\n * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))\n */\nexport function bytesToHex(uint8a) {\n  // pre-caching improves the speed 6x\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  var hex = '';\n  for (var i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n  return hex;\n}\n/**\n * @example hexToBytes('deadbeef')\n */\nexport function hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + _typeof(hex));\n  }\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  var array = new Uint8Array(hex.length / 2);\n  for (var i = 0; i < array.length; i++) {\n    var j = i * 2;\n    var hexByte = hex.slice(j, j + 2);\n    var _byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(_byte) || _byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = _byte;\n  }\n  return array;\n}\n// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise\n// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.\nexport var nextTick = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function nextTick() {\n    return _ref.apply(this, arguments);\n  };\n}();\n// Returns control to thread each 'tick' ms to avoid blocking\nexport function asyncLoop(_x, _x2, _x3) {\n  return _asyncLoop.apply(this, arguments);\n}\nfunction _asyncLoop() {\n  _asyncLoop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(iters, tick, cb) {\n    var ts, i, diff;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          ts = Date.now();\n          i = 0;\n        case 2:\n          if (!(i < iters)) {\n            _context2.next = 13;\n            break;\n          }\n          cb(i);\n          // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n          diff = Date.now() - ts;\n          if (!(diff >= 0 && diff < tick)) {\n            _context2.next = 7;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 10);\n        case 7:\n          _context2.next = 9;\n          return nextTick();\n        case 9:\n          ts += diff;\n        case 10:\n          i++;\n          _context2.next = 2;\n          break;\n        case 13:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _asyncLoop.apply(this, arguments);\n}\nexport function utf8ToBytes(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError(\"utf8ToBytes expected string, got \".concat(_typeof(str)));\n  }\n  return new TextEncoder().encode(str);\n}\nexport function toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!(data instanceof Uint8Array)) throw new TypeError(\"Expected input type is Uint8Array (got \".concat(_typeof(data), \")\"));\n  return data;\n}\n/**\n * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`\n * @example concatBytes(buf1, buf2)\n */\nexport function concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n  if (!arrays.every(function (a) {\n    return a instanceof Uint8Array;\n  })) throw new Error('Uint8Array list expected');\n  if (arrays.length === 1) return arrays[0];\n  var length = arrays.reduce(function (a, arr) {\n    return a + arr.length;\n  }, 0);\n  var result = new Uint8Array(length);\n  for (var i = 0, pad = 0; i < arrays.length; i++) {\n    var arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n  return result;\n}\n// For runtime check if class implements interface\nexport var Hash = /*#__PURE__*/function () {\n  function Hash() {\n    _classCallCheck(this, Hash);\n  }\n  _createClass(Hash, [{\n    key: \"clone\",\n    value:\n    // Safe version that clones internal state\n    function clone() {\n      return this._cloneInto();\n    }\n  }]);\n  return Hash;\n}();\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nvar isPlainObject = function isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n};\nexport function checkOpts(defaults, opts) {\n  if (opts !== undefined && (_typeof(opts) !== 'object' || !isPlainObject(opts))) throw new TypeError('Options should be object or undefined');\n  var merged = Object.assign(defaults, opts);\n  return merged;\n}\nexport function wrapConstructor(hashConstructor) {\n  var hashC = function hashC(message) {\n    return hashConstructor().update(toBytes(message)).digest();\n  };\n  var tmp = hashConstructor();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = function () {\n    return hashConstructor();\n  };\n  return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n  var hashC = function hashC(msg, opts) {\n    return hashCons(opts).update(toBytes(msg)).digest();\n  };\n  var tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = function (opts) {\n    return hashCons(opts);\n  };\n  return hashC;\n}\n/**\n * Secure PRNG\n */\nexport function randomBytes() {\n  var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n  if (crypto.web) {\n    return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n  } else if (crypto.node) {\n    return new Uint8Array(crypto.node.randomBytes(bytesLength).buffer);\n  } else {\n    throw new Error(\"The environment doesn't have randomBytes function\");\n  }\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nexport var crypto = {\n  node: undefined,\n  web: (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === 'object' && 'crypto' in self ? self.crypto : undefined\n};","var U32_MASK64 = BigInt(Math.pow(2, 32) - 1);\nvar _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nexport function fromBig(n) {\n  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (le) return {\n    h: Number(n & U32_MASK64),\n    l: Number(n >> _32n & U32_MASK64)\n  };\n  return {\n    h: Number(n >> _32n & U32_MASK64) | 0,\n    l: Number(n & U32_MASK64) | 0\n  };\n}\nexport function split(lst) {\n  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var Ah = new Uint32Array(lst.length);\n  var Al = new Uint32Array(lst.length);\n  for (var i = 0; i < lst.length; i++) {\n    var _fromBig = fromBig(lst[i], le),\n      h = _fromBig.h,\n      l = _fromBig.l;\n    var _ref = [h, l];\n    Ah[i] = _ref[0];\n    Al[i] = _ref[1];\n  }\n  return [Ah, Al];\n}\nexport var toBig = function toBig(h, l) {\n  return BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n};\n// for Shift in [0, 32)\nvar shrSH = function shrSH(h, l, s) {\n  return h >>> s;\n};\nvar shrSL = function shrSL(h, l, s) {\n  return h << 32 - s | l >>> s;\n};\n// Right rotate for Shift in [1, 32)\nvar rotrSH = function rotrSH(h, l, s) {\n  return h >>> s | l << 32 - s;\n};\nvar rotrSL = function rotrSL(h, l, s) {\n  return h << 32 - s | l >>> s;\n};\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nvar rotrBH = function rotrBH(h, l, s) {\n  return h << 64 - s | l >>> s - 32;\n};\nvar rotrBL = function rotrBL(h, l, s) {\n  return h >>> s - 32 | l << 64 - s;\n};\n// Right rotate for shift===32 (just swaps l&h)\nvar rotr32H = function rotr32H(h, l) {\n  return l;\n};\nvar rotr32L = function rotr32L(h, l) {\n  return h;\n};\n// Left rotate for Shift in [1, 32)\nvar rotlSH = function rotlSH(h, l, s) {\n  return h << s | l >>> 32 - s;\n};\nvar rotlSL = function rotlSL(h, l, s) {\n  return l << s | h >>> 32 - s;\n};\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nvar rotlBH = function rotlBH(h, l, s) {\n  return l << s - 32 | h >>> 64 - s;\n};\nvar rotlBL = function rotlBL(h, l, s) {\n  return h << s - 32 | l >>> 64 - s;\n};\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nexport function add(Ah, Al, Bh, Bl) {\n  var l = (Al >>> 0) + (Bl >>> 0);\n  return {\n    h: Ah + Bh + (l / Math.pow(2, 32) | 0) | 0,\n    l: l | 0\n  };\n}\n// Addition with more than 2 elements\nvar add3L = function add3L(Al, Bl, Cl) {\n  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\n};\nvar add3H = function add3H(low, Ah, Bh, Ch) {\n  return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;\n};\nvar add4L = function add4L(Al, Bl, Cl, Dl) {\n  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\n};\nvar add4H = function add4H(low, Ah, Bh, Ch, Dh) {\n  return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;\n};\nvar add5L = function add5L(Al, Bl, Cl, Dl, El) {\n  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\n};\nvar add5H = function add5H(low, Ah, Bh, Ch, Dh, Eh) {\n  return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;\n};\n// prettier-ignore\nvar u64 = {\n  fromBig: fromBig,\n  split: split,\n  toBig: toBig,\n  shrSH: shrSH,\n  shrSL: shrSL,\n  rotrSH: rotrSH,\n  rotrSL: rotrSL,\n  rotrBH: rotrBH,\n  rotrBL: rotrBL,\n  rotr32H: rotr32H,\n  rotr32L: rotr32L,\n  rotlSH: rotlSH,\n  rotlSL: rotlSL,\n  rotlBH: rotlBH,\n  rotlBL: rotlBL,\n  add: add,\n  add3L: add3L,\n  add3H: add3H,\n  add4L: add4L,\n  add4H: add4H,\n  add5H: add5H,\n  add5L: add5L\n};\nexport default u64;","function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nimport { isEmpty } from \"./arrayUtils\";\nimport { _0n, _10n } from \"./bigIntLiterals\";\nimport { isUndefined } from \"./objectUtils\";\nexport function ensureBigInt(number) {\n  return typeof number === \"bigint\" ? number : BigInt(number);\n}\nexport function undecimalize(decimalStr, options) {\n  if (!decimalStr) {\n    return _0n;\n  }\n  options = typeof options == \"number\" ? {\n    decimals: options\n  } : options;\n  if (isUndefined(options)) {\n    options = {};\n  }\n  options.decimals = options.decimals || 0;\n  options.decimalMark = options.decimalMark || \".\";\n  var fragments = decimalStr.split(options.decimalMark);\n  if (fragments.length > 2) {\n    throw new Error(\"Invalid numeric string.\");\n  }\n  var _fragments = _slicedToArray(fragments, 2),\n    integer = _fragments[0],\n    decimal = _fragments[1];\n  integer = _removeLeadingZeros(integer);\n  var negative = integer.startsWith(\"-\") ? \"-\" : \"\";\n  if (!decimal) {\n    decimal = \"0\".repeat(options.decimals);\n  } else if (decimal.length < options.decimals) {\n    decimal = decimal.padEnd(options.decimals, \"0\");\n  }\n  return BigInt(negative + _stripNonDigits(integer + decimal));\n}\nfunction _stripNonDigits(value) {\n  return value.replace(/\\D/g, \"\");\n}\nexport function decimalize(value, options) {\n  value = ensureBigInt(value);\n  if (!options) {\n    return value.toString();\n  }\n  options = typeof options == \"number\" ? {\n    decimals: options\n  } : options;\n  options.decimals = options.decimals || 0;\n  options.decimalMark = options.decimalMark || \".\";\n  var pow = Math.pow(_10n, BigInt(options.decimals));\n  var integer = value / pow;\n  var decimal = value - integer * pow;\n  return _buildFormattedDecimal(integer.toString(10), decimal.toString(10), options);\n}\nfunction _buildFormattedDecimal(integer, decimal, options) {\n  var integerPart = _addThousandMarks(integer, options.thousandMark);\n  var decimalPart = _stripTrailingZeros(decimal.padStart(options.decimals, \"0\"));\n  if (decimalPart) {\n    return \"\".concat(integerPart).concat(options.decimalMark).concat(decimalPart);\n  } else {\n    return integerPart;\n  }\n}\nfunction _addThousandMarks(value, mark) {\n  if (!mark) {\n    return value;\n  }\n  return value.replace(/\\B(?=(\\d{3})+(?!\\d))/g, mark);\n}\nfunction _stripTrailingZeros(value) {\n  if (!value.endsWith(\"0\")) {\n    return value;\n  }\n  return value.replace(/\\.?0+$/, \"\");\n}\nfunction _removeLeadingZeros(value) {\n  if (!value.startsWith(\"0\")) {\n    return value;\n  }\n  return value.replace(/^0+\\.?/, \"\");\n}\nexport function sumBy(collection, iteratee, condition) {\n  var acc = _0n;\n  if (isEmpty(collection)) {\n    return acc;\n  }\n  var _iterator = _createForOfIteratorHelper(collection),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      if (isUndefined(condition) || condition(item)) {\n        acc += iteratee(item);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return acc;\n}","// Make some ECMAScript parsers happy by not using bigint literals like 123n\nexport var _0n = BigInt(0);\nexport var _1n = BigInt(1);\nexport var _7n = BigInt(7);\nexport var _10n = BigInt(10);\nexport var _63n = BigInt(63);\nexport var _127n = BigInt(127);\nexport var _128n = BigInt(128);","export function isEmpty(obj) {\n  if (!obj) {\n    return true;\n  }\n  return Array.isArray(obj) ? obj.length === 0 : Object.keys(obj).length === 0;\n}\nexport function some(obj) {\n  return !isEmpty(obj);\n}\nexport function first(array) {\n  if (!array) {\n    return;\n  }\n  if (!array[0]) {\n    throw Error(\"Empty array.\");\n  }\n  return array[0];\n}\n/**\n * Check for duplicate elements using the equality operator\n */\nexport function hasDuplicates(array) {\n  return array.some(function (item, index) {\n    return array.indexOf(item) !== index;\n  });\n}\n/**\n * Check for duplicate keys in complex elements\n */\nexport function hasDuplicatesBy(array, selector) {\n  return array.some(function (item, index) {\n    return array.findIndex(function (x) {\n      return selector(x) === selector(item);\n    }) !== index;\n  });\n}\nexport function chunk(array, size) {\n  if (array.length <= size) {\n    return [array];\n  }\n  var chunks = [];\n  for (var i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n  return chunks;\n}\nexport function orderBy(array, iteratee) {\n  var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"asc\";\n  return array.sort(function (a, b) {\n    if (iteratee(a) > iteratee(b)) {\n      return order === \"asc\" ? 1 : -1;\n    } else if (iteratee(a) < iteratee(b)) {\n      return order === \"asc\" ? -1 : 1;\n    } else {\n      return 0;\n    }\n  });\n}\nexport function areEqual(array1, array2) {\n  if (array1 === array2) {\n    return true;\n  }\n  if (array1.length != array2.length) {\n    return false;\n  }\n  for (var i = 0; i < array1.length; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function startsWith(array, target) {\n  if (array === target) {\n    return true;\n  }\n  if (target.length > array.length) {\n    return false;\n  }\n  for (var i = 0; i < target.length; i++) {\n    if (target[i] !== array[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nexport function endsWith(array, target) {\n  if (array === target) {\n    return true;\n  }\n  if (target.length > array.length) {\n    return false;\n  }\n  var offset = array.length - target.length;\n  for (var i = target.length - 1; i >= 0; i--) {\n    if (target[i] !== array[i + offset]) {\n      return false;\n    }\n  }\n  return true;\n}","function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { ensureBigInt, isDefined, isEmpty } from \"@fleet-sdk/common\";\nimport { concatBytes, hexToBytes } from \"@noble/hashes/utils\";\nimport { vlqEncode, vqlEncodeBigInt } from \"../vlq\";\nexport function serializeBox(box) {\n  return concatBytes(vqlEncodeBigInt(ensureBigInt(box.value)), hexToBytes(box.ergoTree), vlqEncode(box.creationHeight), serializeTokens(box.assets), serializeRegisters(box.additionalRegisters), hexToBytes(box.transactionId), vlqEncode(box.index));\n}\nfunction serializeTokens(tokens) {\n  if (isEmpty(tokens)) {\n    return Uint8Array.from([0]);\n  }\n  return concatBytes.apply(void 0, [vlqEncode(tokens.length)].concat(_toConsumableArray(tokens.map(function (asset) {\n    return concatBytes(hexToBytes(asset.tokenId), vqlEncodeBigInt(ensureBigInt(asset.amount)));\n  }))));\n}\nfunction serializeRegisters(registers) {\n  var keys = Object.keys(registers);\n  if (isEmpty(keys)) {\n    return Uint8Array.from([0]);\n  }\n  var serializedRegisters = [];\n  keys = keys.sort();\n  var _iterator = _createForOfIteratorHelper(keys),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      var val = registers[key];\n      if (isDefined(val)) {\n        serializedRegisters.push(hexToBytes(val));\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return concatBytes(vlqEncode(serializedRegisters.length), concatBytes.apply(void 0, serializedRegisters));\n}","import { _0n, _127n, _128n, _7n } from \"@fleet-sdk/common\";\n/**\n * A **variable-length quantity (VLQ)** is a universal code that uses an arbitrary number\n * of binary octets (eight-bit bytes) to represent an arbitrarily large integer. A VLQ\n * is essentially a base-128 representation of an unsigned integer with the addition of\n * the eighth bit to mark continuation of bytes. VLQ is identical to LEB128 except in\n * endianness. See the example below.\n */\n/**\n * Decode VLQ bytes to an unsigned integer value\n * @param reader VLQ bytes\n * @returns Unsigned integer value\n */\nexport function vlqEncode(value) {\n  // source: https://stackoverflow.com/a/3564685\n  if (value === 0) {\n    return Uint8Array.from([0]);\n  } else if (value < 0) {\n    throw new RangeError(\"Variable Length Quantity not supported for negative numbers\");\n  }\n  var bytes = [];\n  do {\n    var lower7bits = value & 0x7f;\n    value >>= 7;\n    if (value > 0) {\n      lower7bits |= 0x80;\n    }\n    bytes.push(lower7bits);\n  } while (value > 0);\n  return Uint8Array.from(bytes);\n}\n/**\n * Decode VLQ bytes to an unsigned integer value\n * @param reader VLQ bytes\n * @returns Unsigned integer value\n */\nexport function vlqDecode(reader) {\n  if (reader.isEmpty) {\n    return 0;\n  }\n  var value = 0;\n  var shift = 0;\n  var lower7bits = 0;\n  do {\n    lower7bits = reader.readByte();\n    value |= (lower7bits & 0x7f) << shift;\n    shift += 7;\n  } while ((lower7bits & 0x80) != 0);\n  return value;\n}\n/**\n * Encode a unsigned big integer to VLQ bytes\n * @param value unsigned bit integer\n * @returns VLQ bytes\n */\nexport function vqlEncodeBigInt(value) {\n  // source: https://stackoverflow.com/a/3564685\n  if (value === _0n) {\n    return Uint8Array.from([0]);\n  } else if (value < _0n) {\n    throw new RangeError(\"Variable Length Quantity not supported for negative numbers\");\n  }\n  var bytes = [];\n  do {\n    var lower7bits = Number(value & _127n);\n    value >>= _7n;\n    if (value > 0) {\n      lower7bits |= 0x80;\n    }\n    bytes.push(lower7bits);\n  } while (value > 0);\n  return Uint8Array.from(bytes);\n}\n/**\n * Decode VLQ bytes to an unsigned big integer value\n * @param reader VLQ bytes\n * @returns Unsigned integer value\n */\nexport function vlqDecodeBigInt(reader) {\n  if (reader.isEmpty) {\n    return _0n;\n  }\n  var value = _0n;\n  var shift = _0n;\n  var lower7bits = _0n;\n  do {\n    lower7bits = BigInt(reader.readByte());\n    value |= (lower7bits & _127n) << shift;\n    shift += _7n;\n  } while ((lower7bits & _128n) != _0n);\n  return value;\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var DuplicateInputError = /*#__PURE__*/function (_Error) {\n  _inherits(DuplicateInputError, _Error);\n  var _super = _createSuper(DuplicateInputError);\n  function DuplicateInputError(boxId) {\n    _classCallCheck(this, DuplicateInputError);\n    return _super.call(this, \"Box '\".concat(boxId, \"' is already included.\"));\n  }\n  return _createClass(DuplicateInputError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var NotFoundError = /*#__PURE__*/function (_Error) {\n  _inherits(NotFoundError, _Error);\n  var _super = _createSuper(NotFoundError);\n  function NotFoundError(message) {\n    _classCallCheck(this, NotFoundError);\n    return _super.call(this, message);\n  }\n  return _createClass(NotFoundError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar _Symbol$iterator;\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { isDefined } from \"@fleet-sdk/common\";\n_Symbol$iterator = Symbol.iterator;\nexport var Collection = /*#__PURE__*/function () {\n  function Collection() {\n    _classCallCheck(this, Collection);\n    _defineProperty(this, \"_items\", void 0);\n    this._items = [];\n  }\n  _createClass(Collection, [{\n    key: \"_isIndexOutOfBounds\",\n    value: function _isIndexOutOfBounds(index) {\n      return index < 0 || index >= this._items.length;\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      var _this = this;\n      var counter = 0;\n      return {\n        next: function next() {\n          return {\n            done: counter >= _this.length,\n            value: _this._items[counter++]\n          };\n        }\n      };\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._items.length;\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this.length === 0;\n    }\n  }, {\n    key: \"at\",\n    value: function at(index) {\n      if (this._isIndexOutOfBounds(index)) {\n        throw new RangeError(\"Index '\".concat(index, \"' is out of range.\"));\n      }\n      return this._items[index];\n    }\n  }, {\n    key: \"add\",\n    value: function add(items, options) {\n      return this._addOneOrMore(items, options);\n    }\n  }, {\n    key: \"_addOne\",\n    value: function _addOne(item, options) {\n      if (isDefined(options) && isDefined(options.index)) {\n        if (options.index === this.length) {\n          this._items.push(this._map(item));\n          return this.length;\n        }\n        if (this._isIndexOutOfBounds(options.index)) {\n          throw new RangeError(\"Index '\".concat(options.index, \"' is out of range.\"));\n        }\n        this._items.splice(options.index, 0, this._map(item));\n        return this.length;\n      }\n      this._items.push(this._map(item));\n      return this._items.length;\n    }\n  }, {\n    key: \"_addOneOrMore\",\n    value: function _addOneOrMore(items, options) {\n      if (Array.isArray(items)) {\n        if (isDefined(options) && isDefined(options.index)) {\n          items = items.reverse();\n        }\n        var _iterator = _createForOfIteratorHelper(items),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var item = _step.value;\n            this._addOne(item, options);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        this._addOne(items, options);\n      }\n      return this.length;\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return _toConsumableArray(this._items);\n    }\n  }]);\n  return Collection;\n}();","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nimport { _0n, isDefined, isUndefined, some } from \"@fleet-sdk/common\";\nimport { NotFoundError } from \"../../errors\";\nimport { Collection } from \"./collection\";\nexport var OutputsCollection = /*#__PURE__*/function (_Collection) {\n  _inherits(OutputsCollection, _Collection);\n  var _super = _createSuper(OutputsCollection);\n  function OutputsCollection(outputs) {\n    var _this;\n    _classCallCheck(this, OutputsCollection);\n    _this = _super.call(this);\n    if (isDefined(outputs)) {\n      _this.add(outputs);\n    }\n    return _this;\n  }\n  _createClass(OutputsCollection, [{\n    key: \"_map\",\n    value: function _map(output) {\n      return output;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(outputs) {\n      var index = -1;\n      if (typeof outputs === \"number\") {\n        if (this._isIndexOutOfBounds(outputs)) {\n          throw new RangeError(\"Index '\".concat(outputs, \"' is out of range.\"));\n        }\n        index = outputs;\n      } else {\n        index = this._items.lastIndexOf(outputs);\n        if (this._isIndexOutOfBounds(index)) {\n          throw new NotFoundError(\"The output you are trying to remove is not present in the outputs collection.\");\n        }\n      }\n      if (index > -1) {\n        this._items.splice(index, 1);\n      }\n      return this.length;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new OutputsCollection(this._items);\n    }\n  }, {\n    key: \"sum\",\n    value: function sum(basis) {\n      var tokens = {};\n      var nanoErgs = _0n;\n      if (basis) {\n        if (basis.nanoErgs) {\n          nanoErgs = basis.nanoErgs;\n        }\n        if (some(basis.tokens)) {\n          var _iterator = _createForOfIteratorHelper(basis.tokens),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var token = _step.value;\n              if (isUndefined(token.amount)) {\n                continue;\n              }\n              tokens[token.tokenId] = (tokens[token.tokenId] || _0n) + token.amount;\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n      var _iterator2 = _createForOfIteratorHelper(this._items),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var box = _step2.value;\n          nanoErgs += box.value;\n          var _iterator3 = _createForOfIteratorHelper(box.tokens),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _token = _step3.value;\n              tokens[_token.tokenId] = (tokens[_token.tokenId] || _0n) + _token.amount;\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return {\n        nanoErgs: nanoErgs,\n        tokens: Object.keys(tokens).map(function (tokenId) {\n          return {\n            tokenId: tokenId,\n            amount: tokens[tokenId]\n          };\n        })\n      };\n    }\n  }]);\n  return OutputsCollection;\n}(Collection);","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { MAX_TOKENS_PER_BOX } from \"../models\";\nexport var TransactionBuilderSettings = /*#__PURE__*/function () {\n  function TransactionBuilderSettings() {\n    _classCallCheck(this, TransactionBuilderSettings);\n    _defineProperty(this, \"_maxDistinctTokensPerChangeBox\", void 0);\n    _defineProperty(this, \"_allowTokenBurn\", void 0);\n    _defineProperty(this, \"_allowTokenPluginFromPlugins\", void 0);\n    this._maxDistinctTokensPerChangeBox = MAX_TOKENS_PER_BOX;\n    this._allowTokenBurn = false;\n    this._allowTokenPluginFromPlugins = false;\n  }\n  _createClass(TransactionBuilderSettings, [{\n    key: \"maxTokensPerChangeBox\",\n    get: function get() {\n      return this._maxDistinctTokensPerChangeBox;\n    }\n  }, {\n    key: \"canBurnTokens\",\n    get: function get() {\n      return this._allowTokenBurn;\n    }\n  }, {\n    key: \"canBurnTokensFromPlugins\",\n    get: function get() {\n      return this.canBurnTokens || this._allowTokenPluginFromPlugins;\n    }\n    /**\n     * Define max number of distinct tokens per change box\n     */\n  }, {\n    key: \"setMaxTokensPerChangeBox\",\n    value: function setMaxTokensPerChangeBox(max) {\n      this._maxDistinctTokensPerChangeBox = max;\n      return this;\n    }\n    /**\n     * Allows or denies token burning from all contexts\n     */\n  }, {\n    key: \"allowTokenBurning\",\n    value: function allowTokenBurning(allow) {\n      this._allowTokenBurn = allow;\n      return this;\n    }\n    /**\n     * Allows or denies token burning **only** from plugins context.\n     */\n  }, {\n    key: \"allowTokenBurningFromPlugins\",\n    value: function allowTokenBurningFromPlugins(allow) {\n      this._allowTokenPluginFromPlugins = allow;\n      return this;\n    }\n  }]);\n  return TransactionBuilderSettings;\n}();","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nimport { isDefined, isUndefined } from \"@fleet-sdk/common\";\nimport { ensureBigInt } from \"@fleet-sdk/common\";\nimport { NotFoundError } from \"../../errors\";\nimport { InsufficientTokenAmount } from \"../../errors/insufficientTokenAmount\";\nimport { MaxTokensOverflow } from \"../../errors/maxTokensOverflow\";\nimport { Collection } from \"./collection\";\nexport var MAX_TOKENS_PER_BOX = 120;\nexport var TokensCollection = /*#__PURE__*/function (_Collection) {\n  _inherits(TokensCollection, _Collection);\n  var _super = _createSuper(TokensCollection);\n  function TokensCollection(tokens, options) {\n    var _this;\n    _classCallCheck(this, TokensCollection);\n    _this = _super.call(this);\n    if (isDefined(tokens)) {\n      _this.add(tokens, options);\n    }\n    return _this;\n  }\n  _createClass(TokensCollection, [{\n    key: \"_map\",\n    value: function _map(token) {\n      return {\n        tokenId: token.tokenId,\n        amount: ensureBigInt(token.amount)\n      };\n    }\n  }, {\n    key: \"_addOne\",\n    value: function _addOne(token, options) {\n      if (isUndefined(options) || options.sum && !isDefined(options.index)) {\n        if (this._sum(this._map(token))) {\n          return this.length;\n        }\n      }\n      if (this._items.length >= MAX_TOKENS_PER_BOX) {\n        throw new MaxTokensOverflow();\n      }\n      _get(_getPrototypeOf(TokensCollection.prototype), \"_addOne\", this).call(this, token, options);\n      return this.length;\n    }\n  }, {\n    key: \"add\",\n    value: function add(items, options) {\n      return _get(_getPrototypeOf(TokensCollection.prototype), \"add\", this).call(this, items, options);\n    }\n  }, {\n    key: \"_sum\",\n    value: function _sum(token) {\n      var _iterator = _createForOfIteratorHelper(this._items),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var t = _step.value;\n          if (t.tokenId === token.tokenId) {\n            t.amount += token.amount;\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(tokenIdOrIndex, amount) {\n      var index = -1;\n      if (typeof tokenIdOrIndex === \"number\") {\n        if (this._isIndexOutOfBounds(tokenIdOrIndex)) {\n          throw new RangeError(\"Index '\".concat(tokenIdOrIndex, \"' is out of range.\"));\n        }\n        index = tokenIdOrIndex;\n      } else {\n        index = this._items.findIndex(function (token) {\n          return token.tokenId === tokenIdOrIndex;\n        });\n        if (this._isIndexOutOfBounds(index)) {\n          throw new NotFoundError(\"TokenId '\".concat(tokenIdOrIndex, \"' not found in assets collection.\"));\n        }\n      }\n      if (amount && index > -1) {\n        var bigAmount = ensureBigInt(amount);\n        var token = this._items[index];\n        if (bigAmount > token.amount) {\n          throw new InsufficientTokenAmount(\"Insufficient token amount to perform a subtraction operation.\");\n        } else if (bigAmount < token.amount) {\n          token.amount -= bigAmount;\n          return this.length;\n        }\n      }\n      if (index > -1) {\n        this._items.splice(index, 1);\n      }\n      return this.length;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(tokenId) {\n      return this._items.some(function (x) {\n        return x.tokenId === tokenId;\n      });\n    }\n  }]);\n  return TokensCollection;\n}(Collection);","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nimport { MAX_TOKENS_PER_BOX } from \"../models/collections/tokensCollection\";\nexport var MaxTokensOverflow = /*#__PURE__*/function (_Error) {\n  _inherits(MaxTokensOverflow, _Error);\n  var _super = _createSuper(MaxTokensOverflow);\n  function MaxTokensOverflow() {\n    _classCallCheck(this, MaxTokensOverflow);\n    return _super.call(this, \"A box must contain no more than \".concat(MAX_TOKENS_PER_BOX, \" distinct tokens.\"));\n  }\n  return _createClass(MaxTokensOverflow);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var InsufficientTokenAmount = /*#__PURE__*/function (_Error) {\n  _inherits(InsufficientTokenAmount, _Error);\n  var _super = _createSuper(InsufficientTokenAmount);\n  function InsufficientTokenAmount(message) {\n    _classCallCheck(this, InsufficientTokenAmount);\n    return _super.call(this, message);\n  }\n  return _createClass(InsufficientTokenAmount);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","var HEX_PATTERN = /^[0-9A-Fa-f]+$/;\nexport function isHex(value) {\n  if (!value) {\n    return false;\n  }\n  return HEX_PATTERN.test(value);\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { AddressType, Network } from \"@fleet-sdk/common\";\nimport { areEqual, endsWith, first, isDefined, startsWith } from \"@fleet-sdk/common\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { bytesToHex, concatBytes, hexToBytes } from \"@noble/hashes/utils\";\nimport { base58 } from \"@scure/base\";\nimport { InvalidAddress } from \"../errors/invalidAddress\";\nvar CHECKSUM_LENGTH = 4;\nvar BLAKE_256_HASH_LENGTH = 32;\nvar P2PK_ERGOTREE_PREFIX = hexToBytes(\"0008cd\");\nvar P2PK_ERGOTREE_LENGTH = 36;\nvar P2SH_ERGOTREE_SUFFIX = hexToBytes(\"d40801\");\nvar P2SH_ERGOTREE_PREFIX = hexToBytes(\"00ea02d193b4cbe4e3010e040004300e18\");\nvar P2SH_ERGOTREE_LENGTH = 44;\nvar P2SH_HASH_LENGTH = 24;\nfunction _getEncodedNetworkType(addressBytes) {\n  return first(addressBytes) & 0xf0;\n}\nfunction _getEncodedAddressType(addressBytes) {\n  return first(addressBytes) & 0xf;\n}\nfunction _ensureBytes(content) {\n  if (typeof content === \"string\") {\n    return hexToBytes(content);\n  }\n  return content;\n}\nfunction blake2b256(input) {\n  return blake2b(input, {\n    dkLen: BLAKE_256_HASH_LENGTH\n  });\n}\nfunction _getErgoTreeType(ergoTree) {\n  if (ergoTree.length === P2PK_ERGOTREE_LENGTH && startsWith(ergoTree, P2PK_ERGOTREE_PREFIX)) {\n    return AddressType.P2PK;\n  } else if (ergoTree.length === P2SH_ERGOTREE_LENGTH && startsWith(ergoTree, P2SH_ERGOTREE_PREFIX) && endsWith(ergoTree, P2SH_ERGOTREE_SUFFIX)) {\n    return AddressType.P2SH;\n  } else {\n    return AddressType.P2S;\n  }\n}\n/**\n * Ergo address model\n *\n * @example\n * Convert address to ErgoTree hex string\n * ```\n * const address = new Address(\"9eZ24iqjKywjzAti9RnWWTR3CiNnLJDAcd2MenKodcAfzc8AFTu\");\n * console.log(address.ergoTree);\n * ```\n *\n * @example\n * Convert ErgoTree hex string to address string\n * ```\n * const ergoTree = \"0008cd026dc059d64a50d0dbf07755c2c4a4e557e3df8afa7141868b3ab200643d437ee7\"\n * const address = Address.fromErgoTree(ergoTree).toString();\n * ```\n */\nexport var ErgoAddress = /*#__PURE__*/function () {\n  /**\n   * New instance from ErgoTree bytes\n   * @param ergoTree ErgoTree bytes\n   */\n  function ErgoAddress(ergoTree, network) {\n    _classCallCheck(this, ErgoAddress);\n    _defineProperty(this, \"_ergoTree\", void 0);\n    _defineProperty(this, \"_network\", void 0);\n    _defineProperty(this, \"_type\", void 0);\n    this._ergoTree = ergoTree;\n    this._network = network;\n    this._type = _getErgoTreeType(ergoTree);\n  }\n  /**\n   * Create a new instance from an ErgoTree\n   * @param ergoTree ErgoTree hex string\n   */\n  _createClass(ErgoAddress, [{\n    key: \"network\",\n    get: function get() {\n      return this._network;\n    }\n    /**\n     * ErgoTree hex string\n     */\n  }, {\n    key: \"ergoTree\",\n    get: function get() {\n      return bytesToHex(this._ergoTree);\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"getPublicKeys\",\n    value: function getPublicKeys() {\n      if (this.type === AddressType.P2PK) {\n        return [this._ergoTree.subarray(P2PK_ERGOTREE_PREFIX.length)];\n      }\n      return [];\n    }\n  }, {\n    key: \"toP2SH\",\n    value: function toP2SH(network) {\n      if (this.type === AddressType.P2SH) {\n        return this.encode();\n      }\n      var hash = blake2b256(this._ergoTree).subarray(0, P2SH_HASH_LENGTH);\n      return this._encode(hash, AddressType.P2SH, network);\n    }\n    /**\n     * Encode address as base58 string\n     */\n  }, {\n    key: \"encode\",\n    value: function encode(network) {\n      var body;\n      if (this.type === AddressType.P2PK) {\n        body = first(this.getPublicKeys());\n      } else if (this.type === AddressType.P2SH) {\n        body = this._ergoTree.subarray(P2SH_ERGOTREE_PREFIX.length, P2SH_ERGOTREE_PREFIX.length + P2SH_HASH_LENGTH);\n      } else {\n        body = this._ergoTree;\n      }\n      return this._encode(body, this.type, network);\n    }\n  }, {\n    key: \"_encode\",\n    value: function _encode(body, type, network) {\n      if (!isDefined(network)) {\n        if (isDefined(this.network)) {\n          network = this.network;\n        } else {\n          network = Network.Mainnet;\n        }\n      }\n      var head = Uint8Array.from([network + type]);\n      body = concatBytes(head, body);\n      var checksum = blake2b256(body).subarray(0, CHECKSUM_LENGTH);\n      return base58.encode(concatBytes(body, checksum));\n    }\n    /**\n     * Encode address as base58 string\n     */\n  }, {\n    key: \"toString\",\n    value: function toString(network) {\n      return this.encode(network);\n    }\n  }], [{\n    key: \"fromErgoTree\",\n    value: function fromErgoTree(ergoTree, network) {\n      return new ErgoAddress(hexToBytes(ergoTree), network);\n    }\n    /**\n     * Create a new instance from a public key\n     * @param publicKey Public key hex string\n     */\n  }, {\n    key: \"fromPublicKey\",\n    value: function fromPublicKey(publicKey, network) {\n      var ergoTree = concatBytes(P2PK_ERGOTREE_PREFIX, _ensureBytes(publicKey));\n      return new ErgoAddress(ergoTree, network);\n    }\n  }, {\n    key: \"fromHash\",\n    value: function fromHash(hash, network) {\n      hash = _ensureBytes(hash);\n      if (hash.length === BLAKE_256_HASH_LENGTH) {\n        hash = hash.subarray(0, P2SH_HASH_LENGTH);\n      } else if (hash.length != P2SH_HASH_LENGTH) {\n        throw Error(\"Invalid hash length: \".concat(hash.length));\n      }\n      var ergoTree = concatBytes(P2SH_ERGOTREE_PREFIX, hash, P2SH_ERGOTREE_SUFFIX);\n      return new ErgoAddress(ergoTree, network);\n    }\n    /**\n     * Create a new checked instance from an address string\n     * @param encodedAddress Address encoded as base58\n     */\n  }, {\n    key: \"fromBase58\",\n    value: function fromBase58(encodedAddress) {\n      var skipCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var bytes = base58.decode(encodedAddress);\n      if (!skipCheck && !ErgoAddress.validate(bytes)) {\n        throw new InvalidAddress(encodedAddress);\n      }\n      var network = _getEncodedNetworkType(bytes);\n      var type = _getEncodedAddressType(bytes);\n      var body = bytes.subarray(1, bytes.length - CHECKSUM_LENGTH);\n      if (type === AddressType.P2PK) {\n        return this.fromPublicKey(body, network);\n      } else if (type === AddressType.P2SH) {\n        return this.fromHash(body, network);\n      } else {\n        return new ErgoAddress(body, network);\n      }\n    }\n    /**\n     * Validate an address\n     * @param address Address bytes or string\n     */\n  }, {\n    key: \"validate\",\n    value: function validate(address) {\n      var bytes = typeof address === \"string\" ? base58.decode(address) : address;\n      if (bytes.length < CHECKSUM_LENGTH) {\n        return false;\n      }\n      var script = bytes.subarray(0, bytes.length - CHECKSUM_LENGTH);\n      var checksum = bytes.subarray(bytes.length - CHECKSUM_LENGTH, bytes.length);\n      var blakeHash = blake2b256(script);\n      var calculatedChecksum = blakeHash.subarray(0, CHECKSUM_LENGTH);\n      return areEqual(calculatedChecksum, checksum);\n    }\n  }, {\n    key: \"getNetworkType\",\n    value: function getNetworkType(address) {\n      return _getEncodedNetworkType(base58.decode(address));\n    }\n  }, {\n    key: \"getAddressType\",\n    value: function getAddressType(address) {\n      return _getEncodedAddressType(base58.decode(address));\n    }\n  }]);\n  return ErgoAddress;\n}();","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nexport function assertNumber(n) {\n  if (!Number.isSafeInteger(n)) throw new Error(\"Wrong integer: \".concat(n));\n}\nfunction chain() {\n  var wrap = function wrap(a, b) {\n    return function (c) {\n      return a(b(c));\n    };\n  };\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  var encode = Array.from(args).reverse().reduce(function (acc, i) {\n    return acc ? wrap(acc, i.encode) : i.encode;\n  }, undefined);\n  var decode = args.reduce(function (acc, i) {\n    return acc ? wrap(acc, i.decode) : i.decode;\n  }, undefined);\n  return {\n    encode: encode,\n    decode: decode\n  };\n}\nfunction alphabet(alphabet) {\n  return {\n    encode: function encode(digits) {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('alphabet.encode input should be an array of numbers');\n      return digits.map(function (i) {\n        assertNumber(i);\n        if (i < 0 || i >= alphabet.length) throw new Error(\"Digit index outside alphabet: \".concat(i, \" (alphabet: \").concat(alphabet.length, \")\"));\n        return alphabet[i];\n      });\n    },\n    decode: function decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('alphabet.decode input should be array of strings');\n      return input.map(function (letter) {\n        if (typeof letter !== 'string') throw new Error(\"alphabet.decode: not string element=\".concat(letter));\n        var index = alphabet.indexOf(letter);\n        if (index === -1) throw new Error(\"Unknown letter: \\\"\".concat(letter, \"\\\". Allowed: \").concat(alphabet));\n        return index;\n      });\n    }\n  };\n}\nfunction join() {\n  var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  if (typeof separator !== 'string') throw new Error('join separator should be string');\n  return {\n    encode: function encode(from) {\n      if (!Array.isArray(from) || from.length && typeof from[0] !== 'string') throw new Error('join.encode input should be array of strings');\n      var _iterator = _createForOfIteratorHelper(from),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var i = _step.value;\n          if (typeof i !== 'string') throw new Error(\"join.encode: non-string input=\".concat(i));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return from.join(separator);\n    },\n    decode: function decode(to) {\n      if (typeof to !== 'string') throw new Error('join.decode input should be string');\n      return to.split(separator);\n    }\n  };\n}\nfunction padding(bits) {\n  var chr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '=';\n  assertNumber(bits);\n  if (typeof chr !== 'string') throw new Error('padding chr should be string');\n  return {\n    encode: function encode(data) {\n      if (!Array.isArray(data) || data.length && typeof data[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      var _iterator2 = _createForOfIteratorHelper(data),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var i = _step2.value;\n          if (typeof i !== 'string') throw new Error(\"padding.encode: non-string input=\".concat(i));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      while (data.length * bits % 8) data.push(chr);\n      return data;\n    },\n    decode: function decode(input) {\n      if (!Array.isArray(input) || input.length && typeof input[0] !== 'string') throw new Error('padding.encode input should be array of strings');\n      var _iterator3 = _createForOfIteratorHelper(input),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var i = _step3.value;\n          if (typeof i !== 'string') throw new Error(\"padding.decode: non-string input=\".concat(i));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var end = input.length;\n      if (end * bits % 8) throw new Error('Invalid padding: string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        if (!((end - 1) * bits % 8)) throw new Error('Invalid padding: string has too much padding');\n      }\n      return input.slice(0, end);\n    }\n  };\n}\nfunction normalize(fn) {\n  if (typeof fn !== 'function') throw new Error('normalize fn should be function');\n  return {\n    encode: function encode(from) {\n      return from;\n    },\n    decode: function decode(to) {\n      return fn(to);\n    }\n  };\n}\nfunction convertRadix(data, from, to) {\n  if (from < 2) throw new Error(\"convertRadix: wrong from=\".concat(from, \", base cannot be less than 2\"));\n  if (to < 2) throw new Error(\"convertRadix: wrong to=\".concat(to, \", base cannot be less than 2\"));\n  if (!Array.isArray(data)) throw new Error('convertRadix: data should be array');\n  if (!data.length) return [];\n  var pos = 0;\n  var res = [];\n  var digits = Array.from(data);\n  digits.forEach(function (d) {\n    assertNumber(d);\n    if (d < 0 || d >= from) throw new Error(\"Wrong integer: \".concat(d));\n  });\n  while (true) {\n    var carry = 0;\n    var done = true;\n    for (var i = pos; i < digits.length; i++) {\n      var digit = digits[i];\n      var digitBase = from * carry + digit;\n      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      carry = digitBase % to;\n      digits[i] = Math.floor(digitBase / to);\n      if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');\n      if (!done) continue;else if (!digits[i]) pos = i;else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (var _i = 0; _i < data.length - 1 && data[_i] === 0; _i++) res.push(0);\n  return res.reverse();\n}\nvar gcd = function gcd(a, b) {\n  return !b ? a : gcd(b, a % b);\n};\nvar radix2carry = function radix2carry(from, to) {\n  return from + (to - gcd(from, to));\n};\nfunction convertRadix2(data, from, to, padding) {\n  if (!Array.isArray(data)) throw new Error('convertRadix2: data should be array');\n  if (from <= 0 || from > 32) throw new Error(\"convertRadix2: wrong from=\".concat(from));\n  if (to <= 0 || to > 32) throw new Error(\"convertRadix2: wrong to=\".concat(to));\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\"convertRadix2: carry overflow from=\".concat(from, \" to=\").concat(to, \" carryBits=\").concat(radix2carry(from, to)));\n  }\n  var carry = 0;\n  var pos = 0;\n  var mask = Math.pow(2, to) - 1;\n  var res = [];\n  var _iterator4 = _createForOfIteratorHelper(data),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var n = _step4.value;\n      assertNumber(n);\n      if (n >= Math.pow(2, from)) throw new Error(\"convertRadix2: invalid data word=\".concat(n, \" from=\").concat(from));\n      carry = carry << from | n;\n      if (pos + from > 32) throw new Error(\"convertRadix2: carry overflow pos=\".concat(pos, \" from=\").concat(from));\n      pos += from;\n      for (; pos >= to; pos -= to) res.push((carry >> pos - to & mask) >>> 0);\n      carry &= Math.pow(2, pos) - 1;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  carry = carry << to - pos & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry) throw new Error(\"Non-zero padding: \".concat(carry));\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\nfunction radix(num) {\n  assertNumber(num);\n  return {\n    encode: function encode(bytes) {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), Math.pow(2, 8), num);\n    },\n    decode: function decode(digits) {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix.decode input should be array of strings');\n      return Uint8Array.from(convertRadix(digits, num, Math.pow(2, 8)));\n    }\n  };\n}\nfunction radix2(bits) {\n  var revPadding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  assertNumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');\n  return {\n    encode: function encode(bytes) {\n      if (!(bytes instanceof Uint8Array)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: function decode(digits) {\n      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== 'number') throw new Error('radix2.decode input should be array of strings');\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    }\n  };\n}\nfunction unsafeWrapper(fn) {\n  if (typeof fn !== 'function') throw new Error('unsafeWrapper fn should be function');\n  return function () {\n    try {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\nfunction checksum(len, fn) {\n  assertNumber(len);\n  if (typeof fn !== 'function') throw new Error('checksum fn should be function');\n  return {\n    encode: function encode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.encode: input should be Uint8Array');\n      var checksum = fn(data).slice(0, len);\n      var res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(checksum, data.length);\n      return res;\n    },\n    decode: function decode(data) {\n      if (!(data instanceof Uint8Array)) throw new Error('checksum.decode: input should be Uint8Array');\n      var payload = data.slice(0, -len);\n      var newChecksum = fn(payload).slice(0, len);\n      var oldChecksum = data.slice(-len);\n      for (var i = 0; i < len; i++) if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    }\n  };\n}\nexport var utils = {\n  alphabet: alphabet,\n  chain: chain,\n  checksum: checksum,\n  radix: radix,\n  radix2: radix2,\n  join: join,\n  padding: padding\n};\nexport var base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexport var base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexport var base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexport var base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize(function (s) {\n  return s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1');\n}));\nexport var base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexport var base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nvar genBase58 = function genBase58(abc) {\n  return chain(radix(58), alphabet(abc), join(''));\n};\nexport var base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexport var base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexport var base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nvar XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexport var base58xmr = {\n  encode: function encode(data) {\n    var res = '';\n    for (var i = 0; i < data.length; i += 8) {\n      var block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n    }\n    return res;\n  },\n  decode: function decode(str) {\n    var res = [];\n    for (var i = 0; i < str.length; i += 11) {\n      var slice = str.slice(i, i + 11);\n      var blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      var block = base58.decode(slice);\n      for (var j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  }\n};\nexport var base58check = function base58check(sha256) {\n  return chain(checksum(4, function (data) {\n    return sha256(sha256(data));\n  }), base58);\n};\nvar BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nvar POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n  var b = pre >> 25;\n  var chk = (pre & 0x1ffffff) << 5;\n  for (var i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];\n  }\n  return chk;\n}\nfunction bechChecksum(prefix, words) {\n  var encodingConst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var len = prefix.length;\n  var chk = 1;\n  for (var i = 0; i < len; i++) {\n    var c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(\"Invalid prefix (\".concat(prefix, \")\"));\n    chk = bech32Polymod(chk) ^ c >> 5;\n  }\n  chk = bech32Polymod(chk);\n  for (var _i2 = 0; _i2 < len; _i2++) chk = bech32Polymod(chk) ^ prefix.charCodeAt(_i2) & 0x1f;\n  var _iterator5 = _createForOfIteratorHelper(words),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var v = _step5.value;\n      chk = bech32Polymod(chk) ^ v;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  for (var _i3 = 0; _i3 < 6; _i3++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % Math.pow(2, 30)], 30, 5, false));\n}\nfunction genBech32(encoding) {\n  var ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  var _words = radix2(5);\n  var fromWords = _words.decode;\n  var toWords = _words.encode;\n  var fromWordsUnsafe = unsafeWrapper(fromWords);\n  function encode(prefix, words) {\n    var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 90;\n    if (typeof prefix !== 'string') throw new Error(\"bech32.encode prefix should be string, not \".concat(_typeof(prefix)));\n    if (!Array.isArray(words) || words.length && typeof words[0] !== 'number') throw new Error(\"bech32.encode words should be array of numbers, not \".concat(_typeof(words)));\n    var actualLength = prefix.length + 7 + words.length;\n    if (limit !== false && actualLength > limit) throw new TypeError(\"Length \".concat(actualLength, \" exceeds limit \").concat(limit));\n    prefix = prefix.toLowerCase();\n    return \"\".concat(prefix, \"1\").concat(BECH_ALPHABET.encode(words)).concat(bechChecksum(prefix, words, ENCODING_CONST));\n  }\n  function decode(str) {\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 90;\n    if (typeof str !== 'string') throw new Error(\"bech32.decode input should be string, not \".concat(_typeof(str)));\n    if (str.length < 8 || limit !== false && str.length > limit) throw new TypeError(\"Wrong string length: \".concat(str.length, \" (\").concat(str, \"). Expected (8..\").concat(limit, \")\"));\n    var lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase()) throw new Error(\"String must be lowercase or uppercase\");\n    str = lowered;\n    var sepIndex = str.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1) throw new Error(\"Letter \\\"1\\\" must be present between prefix and data only\");\n    var prefix = str.slice(0, sepIndex);\n    var _words = str.slice(sepIndex + 1);\n    if (_words.length < 6) throw new Error('Data must be at least 6 characters long');\n    var words = BECH_ALPHABET.decode(_words).slice(0, -6);\n    var sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!_words.endsWith(sum)) throw new Error(\"Invalid checksum in \".concat(str, \": expected \\\"\").concat(sum, \"\\\"\"));\n    return {\n      prefix: prefix,\n      words: words\n    };\n  }\n  var decodeUnsafe = unsafeWrapper(decode);\n  function decodeToBytes(str) {\n    var _decode = decode(str, false),\n      prefix = _decode.prefix,\n      words = _decode.words;\n    return {\n      prefix: prefix,\n      words: words,\n      bytes: fromWords(words)\n    };\n  }\n  return {\n    encode: encode,\n    decode: decode,\n    decodeToBytes: decodeToBytes,\n    decodeUnsafe: decodeUnsafe,\n    fromWords: fromWords,\n    fromWordsUnsafe: fromWordsUnsafe,\n    toWords: toWords\n  };\n}\nexport var bech32 = genBech32('bech32');\nexport var bech32m = genBech32('bech32m');\nexport var utf8 = {\n  encode: function encode(data) {\n    return new TextDecoder().decode(data);\n  },\n  decode: function decode(str) {\n    return new TextEncoder().encode(str);\n  }\n};\nexport var hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize(function (s) {\n  if (typeof s !== 'string' || s.length % 2) throw new TypeError(\"hex.decode: expected string, got \".concat(_typeof(s), \" with length \").concat(s.length));\n  return s.toLowerCase();\n}));\nvar CODERS = {\n  utf8: utf8,\n  hex: hex,\n  base16: base16,\n  base32: base32,\n  base64: base64,\n  base64url: base64url,\n  base58: base58,\n  base58xmr: base58xmr\n};\nvar coderTypeError = \"Invalid encoding type. Available types: \".concat(Object.keys(CODERS).join(', '));\nexport var bytesToString = function bytesToString(type, bytes) {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!(bytes instanceof Uint8Array)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\nexport var str = bytesToString;\nexport var stringToBytes = function stringToBytes(type, str) {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\nexport var bytes = stringToBytes;","export var Network;\n(function (Network) {\n  Network[Network[\"Mainnet\"] = 0] = \"Mainnet\";\n  Network[Network[\"Testnet\"] = 16] = \"Testnet\";\n})(Network || (Network = {}));\nexport var AddressType;\n(function (AddressType) {\n  AddressType[AddressType[\"P2PK\"] = 1] = \"P2PK\";\n  AddressType[AddressType[\"P2SH\"] = 2] = \"P2SH\";\n  AddressType[AddressType[\"P2S\"] = 3] = \"P2S\";\n})(AddressType || (AddressType = {}));","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var InvalidAddress = /*#__PURE__*/function (_Error) {\n  _inherits(InvalidAddress, _Error);\n  var _super = _createSuper(InvalidAddress);\n  function InvalidAddress(address) {\n    _classCallCheck(this, InvalidAddress);\n    return _super.call(this, \"Invalid Ergo address: \".concat(address));\n  }\n  return _createClass(InvalidAddress);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","import { NotAllowedTokenBurning } from \"..\";\nexport function createPluginContext(transactionBuilder) {\n  return {\n    addInputs: function addInputs(inputs) {\n      return transactionBuilder.from(inputs).configureSelector(function (selector) {\n        return selector.ensureInclusion(Array.isArray(inputs) ? inputs.map(function (input) {\n          return input.boxId;\n        }) : inputs.boxId);\n      }).inputs.length;\n    },\n    addOutputs: function addOutputs(outputs, options) {\n      return transactionBuilder.to(outputs, options).outputs.length;\n    },\n    addDataInputs: function addDataInputs(dataInputs, options) {\n      return transactionBuilder.withDataFrom(dataInputs, options).dataInputs.length;\n    },\n    burnTokens: function burnTokens(tokens) {\n      if (!transactionBuilder.settings.canBurnTokensFromPlugins) {\n        throw new NotAllowedTokenBurning();\n      }\n      transactionBuilder.burnTokens(tokens);\n    }\n  };\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var NotAllowedTokenBurning = /*#__PURE__*/function (_Error) {\n  _inherits(NotAllowedTokenBurning, _Error);\n  var _super = _createSuper(NotAllowedTokenBurning);\n  function NotAllowedTokenBurning() {\n    _classCallCheck(this, NotAllowedTokenBurning);\n    return _super.call(this, \"This transaction is trying to burn tokens. If that's your intention you must explicitly allow token burning on TransactionBuilder.configure() method. If no, a change address should be provided.\");\n  }\n  return _createClass(NotAllowedTokenBurning);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var MalformedTransaction = /*#__PURE__*/function (_Error) {\n  _inherits(MalformedTransaction, _Error);\n  var _super = _createSuper(MalformedTransaction);\n  function MalformedTransaction(message) {\n    _classCallCheck(this, MalformedTransaction);\n    return _super.call(this, \"Malformed transaction: \".concat(message));\n  }\n  return _createClass(MalformedTransaction);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var NonStandardizedMinting = /*#__PURE__*/function (_Error) {\n  _inherits(NonStandardizedMinting, _Error);\n  var _super = _createSuper(NonStandardizedMinting);\n  function NonStandardizedMinting(message) {\n    _classCallCheck(this, NonStandardizedMinting);\n    return _super.call(this, message);\n  }\n  return _createClass(NonStandardizedMinting);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { _0n } from \"@fleet-sdk/common\";\nimport { areRegistersDenselyPacked, ensureBigInt, first, isEmpty, isHex, isUndefined, removeUndefined } from \"@fleet-sdk/common\";\nimport { stringToBytes } from \"@scure/base\";\nimport { InvalidRegistersPacking } from \"../errors/invalidRegistersPacking\";\nimport { UndefinedCreationHeight } from \"../errors/undefinedCreationHeight\";\nimport { UndefinedMintingContext } from \"../errors/undefinedMintingContext\";\nimport { ErgoAddress } from \"../models\";\nimport { TokensCollection } from \"../models/collections/tokensCollection\";\nimport { SConstant } from \"../serializer/sigma/constantSerializer\";\nimport { SByte, SColl } from \"../serializer/sigma/sigmaTypes\";\nexport var SAFE_MIN_BOX_VALUE = BigInt(1000000);\nexport var OutputBuilder = /*#__PURE__*/function () {\n  function OutputBuilder(value, recipient, creationHeight) {\n    _classCallCheck(this, OutputBuilder);\n    _defineProperty(this, \"_value\", void 0);\n    _defineProperty(this, \"_address\", void 0);\n    _defineProperty(this, \"_tokens\", void 0);\n    _defineProperty(this, \"_creationHeight\", void 0);\n    _defineProperty(this, \"_registers\", void 0);\n    _defineProperty(this, \"_minting\", void 0);\n    this._value = ensureBigInt(value);\n    this._creationHeight = creationHeight;\n    this._tokens = new TokensCollection();\n    this._registers = {};\n    if (this._value <= _0n) {\n      throw new Error(\"An UTxO cannot be created without a minimum required amount.\");\n    }\n    if (typeof recipient === \"string\") {\n      this._address = isHex(recipient) ? ErgoAddress.fromErgoTree(recipient) : ErgoAddress.fromBase58(recipient);\n    } else {\n      this._address = recipient;\n    }\n  }\n  _createClass(OutputBuilder, [{\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    }\n  }, {\n    key: \"address\",\n    get: function get() {\n      return this._address;\n    }\n  }, {\n    key: \"ergoTree\",\n    get: function get() {\n      return this._address.ergoTree;\n    }\n  }, {\n    key: \"creationHeight\",\n    get: function get() {\n      return this._creationHeight;\n    }\n  }, {\n    key: \"tokens\",\n    get: function get() {\n      return this._tokens;\n    }\n  }, {\n    key: \"additionalRegisters\",\n    get: function get() {\n      return this._registers;\n    }\n  }, {\n    key: \"minting\",\n    get: function get() {\n      return this._minting;\n    }\n  }, {\n    key: \"addTokens\",\n    value: function addTokens(tokens, options) {\n      if (tokens instanceof TokensCollection) {\n        this._tokens.add(tokens.toArray(), options);\n      } else {\n        this._tokens.add(tokens, options);\n      }\n      return this;\n    }\n  }, {\n    key: \"mintToken\",\n    value: function mintToken(token) {\n      this._minting = _objectSpread(_objectSpread({}, token), {}, {\n        amount: ensureBigInt(token.amount)\n      });\n      return this;\n    }\n  }, {\n    key: \"setCreationHeight\",\n    value: function setCreationHeight(height, options) {\n      if (isUndefined(options) || options.replace === true || options.replace === false && isUndefined(this._creationHeight)) {\n        this._creationHeight = height;\n      }\n      return this;\n    }\n  }, {\n    key: \"setAdditionalRegisters\",\n    value: function setAdditionalRegisters(registers) {\n      this._registers = removeUndefined(registers);\n      if (!areRegistersDenselyPacked(registers)) {\n        throw new InvalidRegistersPacking();\n      }\n      return this;\n    }\n  }, {\n    key: \"eject\",\n    value: function eject(ejector) {\n      ejector({\n        tokens: this._tokens\n      });\n      return this;\n    }\n  }, {\n    key: \"build\",\n    value: function build(transactionInputs) {\n      var tokens = this.tokens.toArray();\n      if (this.minting) {\n        if (isEmpty(transactionInputs)) {\n          throw new UndefinedMintingContext();\n        }\n        if (isEmpty(this.additionalRegisters)) {\n          var _this$minting$decimal;\n          this.setAdditionalRegisters({\n            R4: SConstant(SColl(SByte, stringToBytes(\"utf8\", this.minting.name || \"\"))),\n            R5: SConstant(SColl(SByte, stringToBytes(\"utf8\", this.minting.description || \"\"))),\n            R6: SConstant(SColl(SByte, stringToBytes(\"utf8\", ((_this$minting$decimal = this.minting.decimals) === null || _this$minting$decimal === void 0 ? void 0 : _this$minting$decimal.toString()) || \"0\")))\n          });\n        }\n        tokens = [{\n          tokenId: first(transactionInputs).boxId,\n          amount: this.minting.amount\n        }].concat(_toConsumableArray(tokens));\n      }\n      if (isUndefined(this.creationHeight)) {\n        throw new UndefinedCreationHeight();\n      }\n      return {\n        value: this.value.toString(),\n        ergoTree: this.ergoTree,\n        creationHeight: this.creationHeight,\n        assets: tokens.map(function (token) {\n          return {\n            tokenId: token.tokenId,\n            amount: token.amount.toString()\n          };\n        }),\n        additionalRegisters: this.additionalRegisters\n      };\n    }\n  }]);\n  return OutputBuilder;\n}();","function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { _0n } from \"./bigIntLiterals\";\nimport { ensureBigInt } from \"./bigIntUtils\";\nimport { isDefined, isUndefined } from \"./objectUtils\";\nvar NANOERGS_TOKEN_ID = \"nanoErgs\";\nexport function utxoSum(boxes, tokenId) {\n  var balances = {};\n  var _iterator = _createForOfIteratorHelper(boxes),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var box = _step.value;\n      if (isUndefined(tokenId) || tokenId === NANOERGS_TOKEN_ID) {\n        balances[NANOERGS_TOKEN_ID] = (balances[NANOERGS_TOKEN_ID] || _0n) + ensureBigInt(box.value);\n      }\n      if (tokenId !== NANOERGS_TOKEN_ID) {\n        var _iterator2 = _createForOfIteratorHelper(box.assets),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var token = _step2.value;\n            if (isDefined(tokenId) && tokenId !== token.tokenId) {\n              continue;\n            }\n            balances[token.tokenId] = (balances[token.tokenId] || _0n) + ensureBigInt(token.amount);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (isDefined(tokenId)) {\n    return balances[tokenId] || _0n;\n  }\n  return {\n    nanoErgs: balances[NANOERGS_TOKEN_ID],\n    tokens: Object.keys(balances).filter(function (x) {\n      return x !== NANOERGS_TOKEN_ID;\n    }).map(function (tokenId) {\n      return {\n        tokenId: tokenId,\n        amount: balances[tokenId]\n      };\n    })\n  };\n}\nvar MIN_REGISTER_NUMBER = 4;\nvar MAX_REGISTER_NUMBER = 9;\nexport function areRegistersDenselyPacked(registers) {\n  var lastValueIndex = 0;\n  for (var i = MIN_REGISTER_NUMBER; i <= MAX_REGISTER_NUMBER; i++) {\n    if (registers[\"R\".concat(i)]) {\n      if (i === MIN_REGISTER_NUMBER) {\n        lastValueIndex = i;\n        continue;\n      }\n      if (i - lastValueIndex > 1) {\n        return false;\n      }\n      lastValueIndex = i;\n    }\n  }\n  return true;\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var InvalidRegistersPacking = /*#__PURE__*/function (_Error) {\n  _inherits(InvalidRegistersPacking, _Error);\n  var _super = _createSuper(InvalidRegistersPacking);\n  function InvalidRegistersPacking() {\n    _classCallCheck(this, InvalidRegistersPacking);\n    return _super.call(this, \"Registers should be densely packed. This means that it's not possible to use a register like 'R7' without filling 'R6', 'R5' and 'R4', for example.\");\n  }\n  return _createClass(InvalidRegistersPacking);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var UndefinedMintingContext = /*#__PURE__*/function (_Error) {\n  _inherits(UndefinedMintingContext, _Error);\n  var _super = _createSuper(UndefinedMintingContext);\n  function UndefinedMintingContext() {\n    _classCallCheck(this, UndefinedMintingContext);\n    return _super.call(this, \"Creation Height is undefined.\");\n  }\n  return _createClass(UndefinedMintingContext);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","import { DataSerializer } from \"./dataSerializer\";\nimport { SigmaByteReader } from \"./sigmaByteReader\";\nimport { SigmaByteWriter } from \"./sigmaByteWriter\";\nimport { TypeSerializer } from \"./typeSerializer\";\nexport var MAX_CONSTANT_TYPES_LENGTH = 100;\nexport var MAX_CONSTANT_CONTENT_LENGTH = 4096;\nexport var MAX_CONSTANT_LENGTH = MAX_CONSTANT_TYPES_LENGTH + MAX_CONSTANT_CONTENT_LENGTH;\nexport function SConstant(content) {\n  var writer = new SigmaByteWriter(MAX_CONSTANT_LENGTH);\n  TypeSerializer.serialize(content, writer);\n  DataSerializer.serialize(content, writer);\n  return writer.toHex();\n}\nexport function SParse(content) {\n  var reader = new SigmaByteReader(content);\n  var type = reader.readType();\n  return DataSerializer.deserialize(type, reader);\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { _0n } from \"@fleet-sdk/common\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport { vlqEncode, vqlEncodeBigInt } from \"../vlq\";\nimport { zigZagEncode, zigZagEncodeBigInt } from \"../zigZag\";\nexport var SigmaByteWriter = /*#__PURE__*/function () {\n  function SigmaByteWriter(maxLength) {\n    _classCallCheck(this, SigmaByteWriter);\n    _defineProperty(this, \"_bytes\", void 0);\n    _defineProperty(this, \"_cursor\", void 0);\n    this._bytes = new Uint8Array(maxLength);\n    this._cursor = 0;\n  }\n  _createClass(SigmaByteWriter, [{\n    key: \"length\",\n    get: function get() {\n      return this._cursor;\n    }\n  }, {\n    key: \"writeBoolean\",\n    value: function writeBoolean(value) {\n      this.write(value === true ? 0x01 : 0x00);\n      return this;\n    }\n  }, {\n    key: \"writeBooleans\",\n    value: function writeBooleans(elements) {\n      for (var i = 0; i < elements.length; i++) {\n        this.writeBoolean(elements[i]);\n      }\n      return this;\n    }\n  }, {\n    key: \"writeNumber\",\n    value: function writeNumber(value) {\n      this.writeBytes(vlqEncode(zigZagEncode(value)));\n      return this;\n    }\n  }, {\n    key: \"writeLong\",\n    value: function writeLong(value) {\n      this.writeBytes(vqlEncodeBigInt(zigZagEncodeBigInt(value)));\n      return this;\n    }\n  }, {\n    key: \"write\",\n    value: function write(_byte) {\n      this._bytes[this._cursor++] = _byte;\n      return this;\n    }\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(bytes) {\n      this._bytes.set(bytes, this._cursor);\n      this._cursor += bytes.length;\n      return this;\n    }\n  }, {\n    key: \"writeHex\",\n    value: function writeHex(hex) {\n      if (hex.length % 2) {\n        throw new Error(\"Invalid hex padding\");\n      }\n      for (var i = 0; i < hex.length / 2; i++) {\n        var j = i * 2;\n        var _byte2 = Number.parseInt(hex.slice(j, j + 2), 16);\n        if (Number.isNaN(_byte2) || _byte2 < 0) {\n          throw new Error(\"Invalid byte sequence\");\n        }\n        this.write(_byte2);\n      }\n      return this;\n    }\n  }, {\n    key: \"writeBits\",\n    value: function writeBits(bits) {\n      var bitOffset = 0;\n      for (var i = 0; i < bits.length; i++) {\n        if (bits[i]) {\n          this._bytes[this._cursor] |= 1 << bitOffset++;\n        } else {\n          this._bytes[this._cursor] &= ~(1 << bitOffset++);\n        }\n        if (bitOffset == 8) {\n          bitOffset = 0;\n          this._cursor++;\n        }\n      }\n      if (bitOffset > 0) {\n        this._cursor++;\n      }\n      return this;\n    }\n  }, {\n    key: \"writeBigInt\",\n    value: function writeBigInt(number) {\n      // todo: take a look at https://coolaj86.com/articles/convert-decimal-to-hex-with-js-bigints/\n      // and https://coolaj86.com/articles/convert-hex-to-decimal-with-js-bigints/\n      if (number < _0n) {\n        throw new Error(\"Negative BigInt values are not supported Fleet serializer.\");\n      }\n      var hex = number.toString(16);\n      if (hex.length % 2) {\n        hex = \"0\" + hex;\n      } else if (Number.parseInt(hex.substring(0, 1), 16) >= 8) {\n        // maximum positive need to prepend 0 otherwise results in negative number\n        hex = \"00\" + hex;\n      }\n      this.writeBytes(vlqEncode(hex.length / 2));\n      this.writeHex(hex);\n      return this;\n    }\n  }, {\n    key: \"toHex\",\n    value: function toHex() {\n      return bytesToHex(this._bytes.subarray(0, this._cursor));\n    }\n  }, {\n    key: \"toBytes\",\n    value: function toBytes() {\n      return this._bytes.subarray(0, this._cursor);\n    }\n  }]);\n  return SigmaByteWriter;\n}();","import { _1n, _63n } from \"@fleet-sdk/common\";\n/**\n * ZigZag encoding maps signed integers to unsigned integers so that numbers\n * with a small absolute value (for instance, -1) have a small variant encoded\n * value too. It does this in a way that \"zig-zags\" back and forth through the\n * positive and negative integers, so that -1 is encoded as 1, 1 is encoded as 2,\n * -2 is encoded as 3, and so on.\n * @see https://developers.google.com/protocol-buffers/docs/encoding#types\n */\n/**\n * Encode a signed integer.\n * @param input Signed integer\n * @returns ZigZag-encoded value\n */\nexport function zigZagEncode(input) {\n  return input << 1 ^ input >> 63;\n}\n/**\n * Decode a ZigZag-encoded value.\n * @param input ZigZag-encoded value\n * @returns Signed integer\n */\nexport function zigZagDecode(input) {\n  return input >> 1 ^ -(input & 1);\n}\n/**\n * Encode a signed big integer.\n * @param input Signed big integer\n * @returns ZigZag-encoded value\n */\nexport function zigZagEncodeBigInt(input) {\n  return input << _1n ^ input >> _63n;\n}\n/**\n * Decode a ZigZag-encoded value.\n * @param input ZigZag-encoded value\n * @returns Signed big integer\n */\nexport function zigZagDecodeBigInt(input) {\n  return input >> _1n ^ -(input & _1n);\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { isColl, isEmbeddableTypeCode, isPrimitiveType } from \"./utils\";\nexport var TypeSerializer = /*#__PURE__*/function () {\n  function TypeSerializer() {\n    _classCallCheck(this, TypeSerializer);\n  }\n  _createClass(TypeSerializer, null, [{\n    key: \"serialize\",\n    value: function serialize(value, buffer) {\n      if (isPrimitiveType(value)) {\n        buffer.write(value.type);\n      } else if (isColl(value)) {\n        if (isEmbeddableTypeCode(value.elementsType)) {\n          buffer.write(value.type + value.elementsType);\n        }\n      }\n    }\n  }]);\n  return TypeSerializer;\n}();","export function isPrimitiveType(data) {\n  return !isConstructorTypeCode(data.type);\n}\nexport function isColl(data) {\n  return data.type >= 0x0c && data.type <= 0x23;\n}\nexport function isEmbeddableTypeCode(typeCode) {\n  return typeCode >= 0x01 && typeCode <= 0x0b;\n}\nexport function isPrimitiveTypeCode(typeCode) {\n  return !isConstructorTypeCode(typeCode);\n}\nexport function isConstructorTypeCode(type) {\n  return type >= 0x0c && type <= 0x60;\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { hexToBytes } from \"@noble/hashes/utils\";\nimport { vlqEncode } from \"../vlq\";\nimport { SigmaTypeCode } from \"./sigmaTypeCode\";\nimport { isColl, isPrimitiveType, isPrimitiveTypeCode } from \"./utils\";\nexport var DataSerializer = /*#__PURE__*/function () {\n  function DataSerializer() {\n    _classCallCheck(this, DataSerializer);\n  }\n  _createClass(DataSerializer, null, [{\n    key: \"serialize\",\n    value: function serialize(data, buffer) {\n      if (isPrimitiveType(data)) {\n        switch (data.type) {\n          case SigmaTypeCode.Boolean:\n            buffer.writeBoolean(data.value);\n            break;\n          case SigmaTypeCode.Byte:\n            buffer.write(data.value);\n            break;\n          case SigmaTypeCode.Short:\n          case SigmaTypeCode.Int:\n            buffer.writeNumber(data.value);\n            break;\n          case SigmaTypeCode.Long:\n            buffer.writeLong(data.value);\n            break;\n          case SigmaTypeCode.BigInt:\n            {\n              buffer.writeBigInt(data.value);\n              break;\n            }\n          case SigmaTypeCode.GroupElement:\n            buffer.writeBytes(data.value);\n            break;\n          case SigmaTypeCode.SigmaProp:\n            {\n              var node = data.value;\n              if (node.type === SigmaTypeCode.GroupElement) {\n                buffer.write(0xcd); // CreateProveDlog operation\n                DataSerializer.serialize(node, buffer);\n              } else {\n                throw Error(\"Not implemented\");\n              }\n              break;\n            }\n          case SigmaTypeCode.Unit:\n            // same as void, don't need to save anything\n            break;\n          // case SigmaTypeCode.Box:\n          default:\n            throw Error(\"Not implemented\");\n        }\n      } else if (isColl(data)) {\n        if (typeof data.value === \"string\") {\n          buffer.writeBytes(vlqEncode(data.value.length / 2));\n        } else {\n          buffer.writeBytes(vlqEncode(data.value.length));\n        }\n        switch (data.elementsType) {\n          case SigmaTypeCode.Boolean:\n            buffer.writeBits(data.value);\n            break;\n          case SigmaTypeCode.Byte:\n            {\n              var bytes;\n              if (typeof data.value === \"string\") {\n                bytes = hexToBytes(data.value);\n              } else {\n                bytes = Uint8Array.from(data.value);\n              }\n              buffer.writeBytes(bytes);\n              break;\n            }\n          default:\n            for (var i = 0; i < data.value.length; i++) {\n              DataSerializer.serialize({\n                value: data.value[i],\n                type: data.elementsType\n              }, buffer);\n            }\n        }\n      } else {\n        throw Error(\"Not implemented\");\n      }\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(typeCode, reader) {\n      if (isPrimitiveTypeCode(typeCode)) {\n        switch (typeCode) {\n          case SigmaTypeCode.Boolean:\n            return reader.readBoolean();\n          case SigmaTypeCode.Byte:\n            return reader.readByte();\n          case SigmaTypeCode.Short:\n          case SigmaTypeCode.Int:\n            return reader.readNumber();\n          case SigmaTypeCode.Long:\n            return reader.readLong();\n          // case SigmaTypeCode.BigInt:\n          // case SigmaTypeCode.GroupElement:\n          // case SigmaTypeCode.SigmaProp:\n          // case SigmaTypeCode.Unit:\n          // case SigmaTypeCode.Box:\n          // default:\n          //   break;\n        }\n      }\n\n      throw new Error(\"Type parsing not yet implemented.\");\n    }\n  }]);\n  return DataSerializer;\n}();","export var SigmaTypeCode;\n(function (SigmaTypeCode) {\n  SigmaTypeCode[SigmaTypeCode[\"Boolean\"] = 1] = \"Boolean\";\n  SigmaTypeCode[SigmaTypeCode[\"Byte\"] = 2] = \"Byte\";\n  SigmaTypeCode[SigmaTypeCode[\"Short\"] = 3] = \"Short\";\n  SigmaTypeCode[SigmaTypeCode[\"Int\"] = 4] = \"Int\";\n  SigmaTypeCode[SigmaTypeCode[\"Long\"] = 5] = \"Long\";\n  SigmaTypeCode[SigmaTypeCode[\"BigInt\"] = 6] = \"BigInt\";\n  SigmaTypeCode[SigmaTypeCode[\"GroupElement\"] = 7] = \"GroupElement\";\n  SigmaTypeCode[SigmaTypeCode[\"SigmaProp\"] = 8] = \"SigmaProp\";\n  SigmaTypeCode[SigmaTypeCode[\"Coll\"] = 12] = \"Coll\";\n  SigmaTypeCode[SigmaTypeCode[\"NestedColl\"] = 24] = \"NestedColl\";\n  SigmaTypeCode[SigmaTypeCode[\"Option\"] = 36] = \"Option\";\n  SigmaTypeCode[SigmaTypeCode[\"OptionColl\"] = 48] = \"OptionColl\";\n  SigmaTypeCode[SigmaTypeCode[\"Tuple2\"] = 60] = \"Tuple2\";\n  SigmaTypeCode[SigmaTypeCode[\"Tuple3\"] = 72] = \"Tuple3\";\n  SigmaTypeCode[SigmaTypeCode[\"Tuple4\"] = 84] = \"Tuple4\";\n  SigmaTypeCode[SigmaTypeCode[\"TupleN\"] = 96] = \"TupleN\";\n  SigmaTypeCode[SigmaTypeCode[\"Any\"] = 97] = \"Any\";\n  SigmaTypeCode[SigmaTypeCode[\"Unit\"] = 98] = \"Unit\";\n  SigmaTypeCode[SigmaTypeCode[\"Box\"] = 99] = \"Box\";\n  SigmaTypeCode[SigmaTypeCode[\"AvlTree\"] = 100] = \"AvlTree\";\n  SigmaTypeCode[SigmaTypeCode[\"Context\"] = 101] = \"Context\";\n  SigmaTypeCode[SigmaTypeCode[\"Header\"] = 104] = \"Header\";\n  SigmaTypeCode[SigmaTypeCode[\"PreHeader\"] = 105] = \"PreHeader\";\n  SigmaTypeCode[SigmaTypeCode[\"Global\"] = 106] = \"Global\";\n})(SigmaTypeCode || (SigmaTypeCode = {}));","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { isEmpty } from \"@fleet-sdk/common\";\nimport { hexToBytes } from \"@noble/hashes/utils\";\nimport { vlqDecode, vlqDecodeBigInt } from \"../vlq\";\nimport { zigZagDecode, zigZagDecodeBigInt } from \"../zigZag\";\nexport var SigmaByteReader = /*#__PURE__*/function () {\n  function SigmaByteReader(bytes) {\n    _classCallCheck(this, SigmaByteReader);\n    _defineProperty(this, \"_bytes\", void 0);\n    _defineProperty(this, \"_cursor\", void 0);\n    if (typeof bytes === \"string\") {\n      this._bytes = hexToBytes(bytes);\n    } else {\n      this._bytes = bytes;\n    }\n    this._cursor = 0;\n  }\n  _createClass(SigmaByteReader, [{\n    key: \"isEmpty\",\n    get: function get() {\n      return isEmpty(this._bytes);\n    }\n  }, {\n    key: \"readBoolean\",\n    value: function readBoolean() {\n      return this.readByte() === 0x01;\n    }\n  }, {\n    key: \"readByte\",\n    value: function readByte() {\n      return this._bytes[this._cursor++];\n    }\n  }, {\n    key: \"readType\",\n    value: function readType() {\n      return this.readByte();\n    }\n  }, {\n    key: \"readNumber\",\n    value: function readNumber() {\n      return Number(zigZagDecode(vlqDecode(this)));\n    }\n  }, {\n    key: \"readLong\",\n    value: function readLong() {\n      return zigZagDecodeBigInt(vlqDecodeBigInt(this));\n    }\n  }]);\n  return SigmaByteReader;\n}();","import { ensureBigInt, isDefined } from \"@fleet-sdk/common\";\nimport { SigmaTypeCode } from \"./sigmaTypeCode\";\nexport function SByte(value) {\n  return _createPrimitiveType(SigmaTypeCode.Byte, value);\n}\nexport function SBool(value) {\n  return _createPrimitiveType(SigmaTypeCode.Boolean, value);\n}\nexport function SShort(value) {\n  return _createPrimitiveType(SigmaTypeCode.Short, value);\n}\nexport function SInt(value) {\n  return _createPrimitiveType(SigmaTypeCode.Int, value);\n}\nexport function SLong(value) {\n  return _createPrimitiveType(SigmaTypeCode.Long, isDefined(value) ? ensureBigInt(value) : undefined);\n}\nexport function SBigInt(value) {\n  return _createPrimitiveType(SigmaTypeCode.BigInt, isDefined(value) ? ensureBigInt(value) : undefined);\n}\nexport function SUnit() {\n  return _createPrimitiveType(SigmaTypeCode.Unit, null);\n}\nexport function SGroupElement(value) {\n  return _createPrimitiveType(SigmaTypeCode.GroupElement, value);\n}\nexport function SSigmaProp(value) {\n  return _createPrimitiveType(SigmaTypeCode.SigmaProp, value);\n}\nfunction _createPrimitiveType(type, value) {\n  if (value !== undefined) {\n    return {\n      type: type,\n      value: value\n    };\n  } else {\n    return type;\n  }\n}\nexport function SColl(type, elements) {\n  return {\n    type: SigmaTypeCode.Coll,\n    elementsType: type(),\n    value: elements\n  };\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var UndefinedCreationHeight = /*#__PURE__*/function (_Error) {\n  _inherits(UndefinedCreationHeight, _Error);\n  var _super = _createSuper(UndefinedCreationHeight);\n  function UndefinedCreationHeight() {\n    _classCallCheck(this, UndefinedCreationHeight);\n    return _super.call(this, \"Minting context is undefined. Transaction's inputs must be included in order to determine minting token id.\");\n  }\n  return _createClass(UndefinedCreationHeight);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { first, isUndefined } from \"@fleet-sdk/common\";\nimport { _0n, ensureBigInt, hasDuplicatesBy, isDefined, isEmpty, orderBy, some, sumBy, utxoSum } from \"@fleet-sdk/common\";\nimport { DuplicateInputSelectionError } from \"../../errors/duplicateInputSelectionError\";\nimport { InsufficientInputs } from \"../../errors/insufficientInputs\";\nimport { AccumulativeSelectionStrategy } from \"./strategies/accumulativeSelectionStrategy\";\nimport { CustomSelectionStrategy } from \"./strategies/customSelectionStrategy\";\nexport var BoxSelector = /*#__PURE__*/function () {\n  function BoxSelector(inputs) {\n    _classCallCheck(this, BoxSelector);\n    _defineProperty(this, \"_inputs\", void 0);\n    _defineProperty(this, \"_strategy\", void 0);\n    _defineProperty(this, \"_ensureFilterPredicate\", void 0);\n    _defineProperty(this, \"_inputsSortSelector\", void 0);\n    _defineProperty(this, \"_inputsSortDir\", void 0);\n    _defineProperty(this, \"_ensureInclusionBoxIds\", void 0);\n    this._inputs = inputs;\n  }\n  _createClass(BoxSelector, [{\n    key: \"defineStrategy\",\n    value: function defineStrategy(strategy) {\n      if (this._isISelectionStrategyImplementation(strategy)) {\n        this._strategy = strategy;\n      } else {\n        this._strategy = new CustomSelectionStrategy(strategy);\n      }\n      return this;\n    }\n  }, {\n    key: \"select\",\n    value: function select(target) {\n      if (!this._strategy) {\n        this._strategy = new AccumulativeSelectionStrategy();\n      }\n      var remaining = this._deepCloneTarget(target);\n      var unselected = _toConsumableArray(this._inputs);\n      var selected = [];\n      var predicate = this._ensureFilterPredicate;\n      var inclusion = this._ensureInclusionBoxIds;\n      if (isDefined(predicate)) {\n        if (isDefined(inclusion)) {\n          selected = unselected.filter(function (box) {\n            return predicate(box) || inclusion.has(box.boxId);\n          });\n        } else {\n          selected = unselected.filter(predicate);\n        }\n      } else if (isDefined(inclusion)) {\n        selected = unselected.filter(function (box) {\n          return inclusion.has(box.boxId);\n        });\n      }\n      if (isDefined(selected)) {\n        unselected = unselected.filter(function (box) {\n          return !selected.some(function (sel) {\n            return sel.boxId === box.boxId;\n          });\n        });\n        if (isDefined(remaining.nanoErgs)) {\n          remaining.nanoErgs -= sumBy(selected, function (input) {\n            return input.value;\n          });\n        }\n        if (isDefined(remaining.tokens) && selected.some(function (input) {\n          return !isEmpty(input.assets);\n        })) {\n          var _iterator = _createForOfIteratorHelper(remaining.tokens),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var tokenTarget = _step.value;\n              if (tokenTarget.amount) {\n                tokenTarget.amount -= utxoSum(selected, tokenTarget.tokenId);\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n      unselected = this._sort(unselected);\n      selected = selected.concat(this._strategy.select(unselected, remaining));\n      if (hasDuplicatesBy(selected, function (item) {\n        return item.boxId;\n      })) {\n        throw new DuplicateInputSelectionError();\n      }\n      var unreached = this._getUnreachedTargets(selected, target);\n      if (unreached.nanoErgs || some(unreached.tokens)) {\n        throw new InsufficientInputs(unreached);\n      }\n      return selected;\n    }\n  }, {\n    key: \"_deepCloneTarget\",\n    value: function _deepCloneTarget(target) {\n      return {\n        nanoErgs: target.nanoErgs,\n        tokens: isDefined(target.tokens) ? target.tokens.map(function (t) {\n          return {\n            tokenId: t.tokenId,\n            amount: t.amount\n          };\n        }) : undefined\n      };\n    }\n  }, {\n    key: \"_getUnreachedTargets\",\n    value: function _getUnreachedTargets(inputs, target) {\n      var unreached = {\n        nanoErgs: undefined,\n        tokens: undefined\n      };\n      var selectedNanoergs = sumBy(inputs, function (input) {\n        return input.value;\n      });\n      if (target.nanoErgs && target.nanoErgs > selectedNanoergs) {\n        unreached.nanoErgs = target.nanoErgs - selectedNanoergs;\n      }\n      if (isEmpty(target.tokens)) {\n        return unreached;\n      }\n      var _iterator2 = _createForOfIteratorHelper(target.tokens),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var tokenTarget = _step2.value;\n          var totalSelected = utxoSum(inputs, tokenTarget.tokenId);\n          if (isDefined(tokenTarget.amount) && tokenTarget.amount > totalSelected) {\n            if (tokenTarget.tokenId === first(inputs).boxId) {\n              continue;\n            }\n            if (isUndefined(unreached.tokens)) {\n              unreached.tokens = [];\n            }\n            unreached.tokens.push({\n              tokenId: tokenTarget.tokenId,\n              amount: tokenTarget.amount - totalSelected\n            });\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return unreached;\n    }\n  }, {\n    key: \"_sort\",\n    value: function _sort(inputs) {\n      if (!this._inputsSortSelector) {\n        return orderBy(inputs, function (input) {\n          return input.creationHeight;\n        }, \"asc\");\n      }\n      return orderBy(inputs, this._inputsSortSelector, this._inputsSortDir || \"asc\");\n    }\n  }, {\n    key: \"ensureInclusion\",\n    value: function ensureInclusion(predicateOrBoxIds) {\n      if (typeof predicateOrBoxIds === \"function\") {\n        this._ensureFilterPredicate = predicateOrBoxIds;\n      } else {\n        if (isUndefined(this._ensureInclusionBoxIds)) {\n          this._ensureInclusionBoxIds = new Set();\n        }\n        if (Array.isArray(predicateOrBoxIds)) {\n          var _iterator3 = _createForOfIteratorHelper(predicateOrBoxIds),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var boxId = _step3.value;\n              this._ensureInclusionBoxIds.add(boxId);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else {\n          this._ensureInclusionBoxIds.add(predicateOrBoxIds);\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"orderBy\",\n    value: function orderBy(selector, direction) {\n      this._inputsSortSelector = selector;\n      this._inputsSortDir = direction;\n      return this;\n    }\n  }, {\n    key: \"_isISelectionStrategyImplementation\",\n    value: function _isISelectionStrategyImplementation(obj) {\n      if (obj.select) {\n        return true;\n      }\n      return false;\n    }\n  }], [{\n    key: \"buildTargetFrom\",\n    value: function buildTargetFrom(boxes) {\n      var tokens = {};\n      var nanoErgs = _0n;\n      var _iterator4 = _createForOfIteratorHelper(boxes),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var box = _step4.value;\n          nanoErgs += ensureBigInt(box.value);\n          var _iterator5 = _createForOfIteratorHelper(box.assets),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var token = _step5.value;\n              tokens[token.tokenId] = (tokens[token.tokenId] || _0n) + ensureBigInt(token.amount);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return {\n        nanoErgs: nanoErgs,\n        tokens: Object.keys(tokens).map(function (tokenId) {\n          return {\n            tokenId: tokenId,\n            amount: tokens[tokenId]\n          };\n        })\n      };\n    }\n  }]);\n  return BoxSelector;\n}();","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/**\n * Custom selection strategy supports custom selections implementations.\n */\nexport var CustomSelectionStrategy = /*#__PURE__*/function () {\n  function CustomSelectionStrategy(selector) {\n    _classCallCheck(this, CustomSelectionStrategy);\n    _defineProperty(this, \"_selector\", void 0);\n    this._selector = selector;\n  }\n  _createClass(CustomSelectionStrategy, [{\n    key: \"select\",\n    value: function select(inputs, target) {\n      return this._selector(inputs, target);\n    }\n  }]);\n  return CustomSelectionStrategy;\n}();","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { _0n, isEmpty, isUndefined, sumBy, utxoSum } from \"@fleet-sdk/common\";\n/**\n * Accumulative selection strategy accumulates inputs until the target\n * value is reached, skipping detrimental inputs.\n */\nexport var AccumulativeSelectionStrategy = /*#__PURE__*/function () {\n  function AccumulativeSelectionStrategy() {\n    _classCallCheck(this, AccumulativeSelectionStrategy);\n    _defineProperty(this, \"_inputs\", void 0);\n  }\n  _createClass(AccumulativeSelectionStrategy, [{\n    key: \"select\",\n    value: function select(inputs, target) {\n      this._inputs = inputs;\n      var selection = [];\n      if (!isEmpty(target.tokens)) {\n        selection = this._selectTokens(target.tokens);\n      }\n      var selectedNanoErgs = sumBy(selection, function (input) {\n        return input.value;\n      });\n      if (isUndefined(target.nanoErgs) && isEmpty(target.tokens) || !isUndefined(target.nanoErgs) && selectedNanoErgs < target.nanoErgs) {\n        var targetAmount = !isUndefined(target.nanoErgs) ? target.nanoErgs - selectedNanoErgs : undefined;\n        selection = selection.concat(this._select(targetAmount));\n      }\n      return selection;\n    }\n  }, {\n    key: \"_selectTokens\",\n    value: function _selectTokens(targets) {\n      var selection = [];\n      var _iterator = _createForOfIteratorHelper(targets),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var target = _step.value;\n          var targetAmount = !isUndefined(target.amount) ? target.amount - utxoSum(selection, target.tokenId) : undefined;\n          if (targetAmount && targetAmount <= _0n) {\n            continue;\n          }\n          selection = selection.concat(this._select(targetAmount, target.tokenId));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return selection;\n    }\n  }, {\n    key: \"_select\",\n    value: function _select(target, tokenId) {\n      var acc = _0n;\n      var selection = [];\n      if (isUndefined(target)) {\n        if (tokenId) {\n          selection = this._inputs.filter(function (x) {\n            return x.assets.some(function (asset) {\n              return asset.tokenId === tokenId;\n            });\n          });\n        } else {\n          selection = this._inputs;\n        }\n      } else {\n        for (var i = 0; i < this._inputs.length && acc < target; i++) {\n          if (tokenId) {\n            var _iterator2 = _createForOfIteratorHelper(this._inputs[i].assets),\n              _step2;\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var token = _step2.value;\n                if (token.tokenId !== tokenId) {\n                  continue;\n                }\n                acc += token.amount;\n                selection.push(this._inputs[i]);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          } else {\n            acc += this._inputs[i].value;\n            selection.push(this._inputs[i]);\n          }\n        }\n      }\n      if (!isEmpty(selection)) {\n        this._inputs = this._inputs.filter(function (input) {\n          return !selection.includes(input);\n        });\n      }\n      return selection;\n    }\n  }]);\n  return AccumulativeSelectionStrategy;\n}();","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var DuplicateInputSelectionError = /*#__PURE__*/function (_Error) {\n  _inherits(DuplicateInputSelectionError, _Error);\n  var _super = _createSuper(DuplicateInputSelectionError);\n  function DuplicateInputSelectionError() {\n    _classCallCheck(this, DuplicateInputSelectionError);\n    return _super.call(this, \"One or more inputs was selected more than one time by the current selection strategy.\");\n  }\n  return _createClass(DuplicateInputSelectionError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { some } from \"@fleet-sdk/common\";\nexport var InsufficientInputs = /*#__PURE__*/function (_Error) {\n  _inherits(InsufficientInputs, _Error);\n  var _super = _createSuper(InsufficientInputs);\n  function InsufficientInputs(unreached) {\n    var _this;\n    _classCallCheck(this, InsufficientInputs);\n    var strings = [];\n    if (unreached.nanoErgs) {\n      strings.push(buildString(\"nanoErgs\", unreached.nanoErgs));\n    }\n    if (some(unreached.tokens)) {\n      var _iterator = _createForOfIteratorHelper(unreached.tokens),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var token = _step.value;\n          strings.push(buildString(token.tokenId, token.amount));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    _this = _super.call(this, \"Insufficient inputs:\".concat(strings.join()));\n    _defineProperty(_assertThisInitialized(_this), \"unreached\", void 0);\n    _this.unreached = unreached;\n    return _this;\n  }\n  return _createClass(InsufficientInputs);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nfunction buildString(tokenId, amount) {\n  return \"\\n  > \".concat(tokenId, \": \").concat(amount === null || amount === void 0 ? void 0 : amount.toString());\n}","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nexport var InvalidInput = /*#__PURE__*/function (_Error) {\n  _inherits(InvalidInput, _Error);\n  var _super = _createSuper(InvalidInput);\n  function InvalidInput(boxId) {\n    _classCallCheck(this, InvalidInput);\n    return _super.call(this, \"Invalid input: \".concat(boxId));\n  }\n  return _createClass(InvalidInput);\n}( /*#__PURE__*/_wrapNativeSuper(Error));","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t0: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","__webpack_require__.nc = undefined;","function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nimport './styles/style.css';\nimport './styles/enter-button.css';\nimport './app.js';\nimport './fleet.js';\nvar mintbtn = document.getElementById(\"mintbtn\");\nvar connectbtn = document.getElementById(\"connectbtn\");\nfunction connect() {\n  return _connect.apply(this, arguments);\n}\nfunction _connect() {\n  _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    var ConnectUserWallet, UserAddress, cypxAmount, mintbtn, UserBalance, UserBalanceErg, dashboardbtn, assets, assetsHTML, audioNFTs, audioNFTsContainer, audioNFTsHTML;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return ergoConnector.nautilus.connect();\n        case 2:\n          ConnectUserWallet = _context3.sent;\n          ConnectUserWallet;\n          document.getElementById(\"calendar\").style.display = \"flex\";\n          _context3.next = 7;\n          return ergo.get_change_address();\n        case 7:\n          UserAddress = _context3.sent;\n          _context3.next = 10;\n          return displayCypxAmount(UserAddress);\n        case 10:\n          cypxAmount = _context3.sent;\n          mintbtn = document.getElementById(\"mintbtn\");\n          _context3.next = 14;\n          return ergo.get_balance();\n        case 14:\n          UserBalance = _context3.sent;\n          UserBalanceErg = UserBalance / Math.pow(10, 9);\n          dashboardbtn = document.getElementById(\"dashboardbtn\");\n          dashboardbtn.style.display = \"flex\";\n          connectbtn.style.display = \"none\";\n          console.log(UserAddress);\n          console.log(UserBalanceErg);\n          document.getElementById(\"userbalance\").style.display = \"flex\";\n          document.getElementById(\"userbalance\").innerHTML = \"<img src=\\\"./dist/assets/ergicon.png\\\" id=\\\"balanceicon\\\">   \" + UserBalanceErg;\n          document.getElementById(\"cypxbalance\").innerHTML = \"<img src=\\\"./dist/assets/cypxicon.png\\\" id=\\\"cypxicon\\\">\" + cypxAmount / Math.pow(10, 4);\n          _context3.next = 26;\n          return displayCybercitizenAssets(UserAddress);\n        case 26:\n          assets = _context3.sent;\n          assetsHTML = '';\n          _context3.next = 30;\n          return displayAudioNFTs(UserAddress);\n        case 30:\n          audioNFTs = _context3.sent;\n          audioNFTsContainer = document.getElementById(\"audio-nfts\");\n          audioNFTsContainer.style.display = \"block\";\n          audioNFTsHTML = '';\n          audioNFTs.forEach(function (audioNFT) {\n            audioNFTsHTML += \"\\n      <div>\\n        <p class = \\\"assettitle\\\">CyberVerse  Audio NFT:</p><p class=\\\"assetdescription\\\"> \".concat(audioNFT.name, \"</p>\\n      </div>\\n    \");\n          });\n          audioNFTsContainer.innerHTML = audioNFTsHTML;\n        case 36:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _connect.apply(this, arguments);\n}\nfunction displayCypxAmount(_x) {\n  return _displayCypxAmount.apply(this, arguments);\n}\nfunction _displayCypxAmount() {\n  _displayCypxAmount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(userAddress) {\n    var response, data, cypxAmount;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          _context4.next = 2;\n          return fetch(\"https://api.ergoplatform.com/api/v1/boxes/unspent/byAddress/\".concat(userAddress));\n        case 2:\n          response = _context4.sent;\n          _context4.next = 5;\n          return response.json();\n        case 5:\n          data = _context4.sent;\n          cypxAmount = 0;\n          data.items.forEach(function (item) {\n            item.assets.forEach(function (asset) {\n              if (asset.name === \"CYPX\") {\n                cypxAmount += asset.amount;\n              }\n            });\n          });\n          console.log(\"CYPX Amount: \".concat(cypxAmount));\n          return _context4.abrupt(\"return\", cypxAmount);\n        case 10:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _displayCypxAmount.apply(this, arguments);\n}\nfunction formatTime(seconds) {\n  var minutes = Math.floor(seconds / 60);\n  var remainingSeconds = Math.floor(seconds % 60);\n  return \"\".concat(minutes, \":\").concat(remainingSeconds.toString().padStart(2, '0'));\n}\nfunction displayCybercitizenAssets(_x2) {\n  return _displayCybercitizenAssets.apply(this, arguments);\n}\nfunction _displayCybercitizenAssets() {\n  _displayCybercitizenAssets = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(userAddress) {\n    var response, data, cybercitizenAssets, assetsHTML, dashboard;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          _context5.next = 2;\n          return fetch(\"https://api.ergoplatform.com/api/v1/boxes/unspent/byAddress/\".concat(userAddress));\n        case 2:\n          response = _context5.sent;\n          _context5.next = 5;\n          return response.json();\n        case 5:\n          data = _context5.sent;\n          cybercitizenAssets = [];\n          data.items.forEach(function (item) {\n            item.assets.forEach(function (asset) {\n              if (asset.name.includes(\"Cybercitizen\")) {\n                var assetNum = asset.name.match(/#(\\d+)/)[1];\n                cybercitizenAssets.push({\n                  name: asset.name,\n                  tokenId: asset.tokenId,\n                  amount: asset.amount,\n                  imgSrc: \"./dist/pages/gen2/assets/cc-images/\".concat(assetNum, \".png\"),\n                  imgSrcingame: \"./dist/pages/gen2/assets/in-game/\".concat(assetNum, \".png\")\n                });\n              }\n            });\n          });\n          assetsHTML = '';\n          cybercitizenAssets.forEach(function (asset) {\n            assetsHTML += \"\\n          <div class=\\\"assetcont\\\">\\n            <p class = \\\"assettitle\\\"></p> <p class=\\\"assetdescription\\\">\".concat(asset.name, \"</p>\\n            <p class=\\\"assettitle\\\">Token ID:</p> <p class=\\\"assetdescription\\\"> \").concat(asset.tokenId, \"</p>\\n            <img class=\\\"ccimage\\\" src=\\\"\").concat(asset.imgSrc, \"\\\" />\\n            <img class=\\\"ccimage\\\" src=\\\"\").concat(asset.imgSrcingame, \"\\\" />\\n          </div>\\n        \");\n            console.log(JSON.stringify(cybercitizenAssets));\n          });\n          dashboard = document.getElementById(\"dashboard\");\n          dashboard.innerHTML += assetsHTML;\n          return _context5.abrupt(\"return\", cybercitizenAssets);\n        case 13:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n  return _displayCybercitizenAssets.apply(this, arguments);\n}\nfunction displayAudioNFTs(_x3) {\n  return _displayAudioNFTs.apply(this, arguments);\n}\nfunction _displayAudioNFTs() {\n  _displayAudioNFTs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(userAddress) {\n    var response, data, audioNFTs, audioNFTsHTML, audioNFTsElement, playButtons;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          _context6.next = 2;\n          return fetch(\"https://api.ergoplatform.com/api/v1/boxes/unspent/byAddress/\".concat(userAddress));\n        case 2:\n          response = _context6.sent;\n          _context6.next = 5;\n          return response.json();\n        case 5:\n          data = _context6.sent;\n          audioNFTs = [];\n          data.items.forEach(function (item) {\n            item.assets.forEach(function (asset) {\n              if (['Laser Guns', 'Outrun', 'Danger Zone', 'Cyberlykos', 'Blue Lights', 'Into Cyberia'].includes(asset.name)) {\n                audioNFTs.push({\n                  name: asset.name\n                });\n              }\n            });\n          });\n          audioNFTsHTML = '';\n          audioNFTs.forEach(function (audioNFT) {\n            audioNFTsHTML += \"\\n          <div class=\\\"assetcont\\\">\\n            <p class=\\\"assettitle\\\">CyberVerse Track Name:</p>\\n            <p class=\\\"assetdescription\\\">\".concat(audioNFT.name, \"</p>\\n            <button class=\\\"play-button\\\" data-asset=\\\"\").concat(audioNFT.name, \"\\\">Play</button>\\n            <button class=\\\"pause-button\\\" data-asset=\\\"\").concat(audioNFT.name, \"\\\" style=\\\"display:none;\\\">Pause</button>\\n            <div class=\\\"seek-container\\\">\\n              <input class=\\\"seek-bar\\\" type=\\\"range\\\" min=\\\"0\\\" step=\\\"1\\\" value=\\\"0\\\">\\n              <span class=\\\"current-time\\\">0:00 </span><span>/</span>\\n              <span class=\\\"duration\\\">0:00</span>\\n            </div>\\n          </div>\\n        \");\n          });\n          audioNFTsElement = document.getElementById(\"audio-nfts\");\n          audioNFTsElement.innerHTML = audioNFTsHTML;\n\n          // add event listeners to play buttons\n          playButtons = document.querySelectorAll('.play-button');\n          playButtons.forEach(function (button) {\n            var assetName = button.dataset.asset;\n            var audio = new Audio(\"./dist/assets/audio-dashboard/\".concat(assetName.replace(/ /g, '_'), \".wav\"));\n            var audioPlayer;\n            var seekBar = button.parentElement.querySelector('.seek-bar');\n            var currentTime = button.parentElement.querySelector('.current-time');\n            var duration = button.parentElement.querySelector('.duration');\n            audio.addEventListener('loadedmetadata', function () {\n              duration.textContent = formatTime(audio.duration);\n              seekBar.max = audio.duration;\n            });\n            seekBar.addEventListener('input', function () {\n              currentTime.textContent = formatTime(seekBar.value);\n              audio.currentTime = seekBar.value;\n            });\n            button.addEventListener('click', function () {\n              audio.play();\n              audioPlayer = audio;\n              button.style.display = 'none';\n              button.nextElementSibling.style.display = 'inline-block'; // show the pause button\n            });\n\n            // add event listeners to pause buttons\n            var pauseButtons = document.querySelectorAll('.pause-button');\n            pauseButtons.forEach(function (pauseButton) {\n              pauseButton.addEventListener('click', function () {\n                audioPlayer.pause();\n                pauseButton.style.display = 'none';\n                pauseButton.previousElementSibling.style.display = 'inline-block'; // show the play button\n              });\n            });\n\n            // update seek bar as audio plays\n            audio.addEventListener('timeupdate', function () {\n              seekBar.value = audio.currentTime;\n              currentTime.textContent = formatTime(audio.currentTime);\n            });\n\n            // add event listener to window to check if\n\n            window.addEventListener('blur', function () {\n              audioNFTs.forEach(function (audioNFT) {\n                var audio = new Audio(\"./dist/assets/audio-dashboard/\".concat(audioNFT.name.replace(/ /g, '_'), \".wav\"));\n                var isPlaying = false;\n                var duration = 0;\n                var seekBar = null;\n                audio.addEventListener('play', function () {\n                  isPlaying = true;\n                  duration = audio.duration;\n                  seekBar.max = duration;\n                });\n                audio.addEventListener('pause', function () {\n                  isPlaying = false;\n                });\n                audio.addEventListener('timeupdate', function () {\n                  if (isPlaying) {\n                    seekBar.value = audio.currentTime;\n                  }\n                });\n                var playButton = document.querySelector(\".play-button[data-asset=\\\"\".concat(audioNFT.name, \"\\\"]\"));\n                var pauseButton = document.querySelector(\".pause-button[data-asset=\\\"\".concat(audioNFT.name, \"\\\"]\"));\n                seekBar = document.querySelector(\".seek-bar[data-asset=\\\"\".concat(audioNFT.name, \"\\\"]\"));\n                playButton.addEventListener('click', function () {\n                  audio.play();\n                  isPlaying = true;\n                  playButton.style.display = 'none';\n                  pauseButton.style.display = 'inline-block';\n                });\n                pauseButton.addEventListener('click', function () {\n                  audio.pause();\n                  isPlaying = false;\n                  pauseButton.style.display = 'none';\n                  playButton.style.display = 'inline-block';\n                });\n                seekBar.addEventListener('input', function () {\n                  audio.currentTime = seekBar.value;\n                });\n              });\n            });\n          });\n        case 14:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6);\n  }));\n  return _displayAudioNFTs.apply(this, arguments);\n}\nvar displaybtn = document.getElementById(\"dashboardbtn\");\ndisplaybtn.addEventListener(\"click\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n  return _regeneratorRuntime().wrap(function _callee$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        dashboardmodal.style.display = \"block\";\n      case 1:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _callee);\n})));\nvar closebtn = document.getElementById(\"closedashboard\");\nclosebtn.addEventListener(\"click\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        dashboardmodal.style.display = \"none\";\n      case 1:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, _callee2);\n})));\nvar buttonContainer = document.createElement('div');\ndocument.getElementById('calendar').appendChild(buttonContainer);\nfunction createButtonsForCurrentMonth() {\n  var today = new Date();\n  var currentMonth = today.getMonth();\n  var currentYear = today.getFullYear();\n  var daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();\n  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n  var currentMonthName = monthNames[currentMonth];\n  buttonContainer.innerHTML = \"<span id=\\\"statsdisplay\\\">Barman Stats:</span><p id=\\\"monthdisplay\\\">\".concat(currentMonthName, \"</p>\");\n  var _loop = function _loop() {\n    if (day > today.getDate()) {\n      return \"break\";\n    }\n    var dateParam = \"\".concat(currentMonth + 1, \"/\").concat(day, \"/\").concat(currentYear);\n    var button = document.createElement('button');\n    button.textContent = day;\n    button.addEventListener('click', function () {\n      var requestUrl = 'https://playcyberverse.com/api/leaderboard';\n      var requestBody = {\n        \"pass\": process.env.MY_SECRET_PASS,\n        \"name\": \"barman\",\n        \"date\": dateParam\n      };\n      // remove all buttons before showing spinner\n      buttonContainer.innerHTML = '<p style=\"color:var(--yellow) ;font-size:x-small\">Loading Data ... </p>';\n      setTimeout(function () {\n        fetch(requestUrl, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify(requestBody)\n        }).then(function (response) {\n          if (!response.ok) {\n            throw new Error('Response not ok');\n          }\n          return response.json();\n        }).then(function (response) {\n          var data = response.data;\n          if (data.length === 0) {\n            alert('No one has played on this day yet!');\n            createButtonsForCurrentMonth();\n            return;\n          }\n          var datepoints = document.getElementById('datepoints');\n          var html = '<h1>Leaderboard Stats for ' + \"\".concat(dateParam) + '</h1>';\n          data.forEach(function (item) {\n            html += \"<p><span class=\\\"maintext\\\">Address: </span><span class=\\\"subtext\\\"> \".concat(item.address, \"    </span><span class=\\\"maintext\\\">Points: </span><span class=\\\"subtext\\\"> \").concat(item.points, \"</span></p>\");\n          });\n          datepoints.innerHTML = html;\n          var datemodal = document.getElementById(\"datemodal\").style.display = \"block\";\n          // clear the button container and re-populate it with buttons\n          setTimeout(function () {\n            buttonContainer.innerHTML = '';\n            createButtonsForCurrentMonth();\n          }, 500);\n        })[\"catch\"](function (error) {\n          console.error(error);\n          alert('Error retrieving data. Please try again later.');\n          createButtonsForCurrentMonth();\n        });\n      }, 500);\n    });\n    buttonContainer.appendChild(button);\n  };\n  for (var day = 1; day <= daysInMonth; day++) {\n    var _ret = _loop();\n    if (_ret === \"break\") break;\n  }\n\n  // hide the calendar only after the buttons have been created\n}\n\n// create the buttons for the current month on page load\ncreateButtonsForCurrentMonth();\nconnectbtn.addEventListener(\"click\", connect);"],"names":[],"sourceRoot":""}